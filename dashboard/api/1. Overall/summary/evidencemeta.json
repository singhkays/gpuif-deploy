{"queries":[{"id":"wow_listings","compiledQueryString":"-- wow_listings\n\n-- Step 0: Calculate daily average of unique prices per GPU_Name\nWITH daily_gpu_name_unique_price_avg AS (\n  SELECT\n    DATE_TRUNC('day', MessageDateTime) AS SaleDate,\n    \"GPU_Name\",\n    AVG(Price) AS AvgOfUniquePrices -- This AVG is over distinct prices for this GPU_Name on this SaleDate\n  FROM (\n    SELECT DISTINCT\n        DATE_TRUNC('day', MessageDateTime) AS SaleDate_inner, -- Renamed to avoid ambiguity in some DBs\n        MessageDateTime, -- Keep original for joining later if needed, or for week calculation\n        \"GPU_Name\",\n        Price\n    FROM gpu_data.gpu\n    WHERE \"GPU_Name\" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')\n      AND Price IS NOT NULL AND Price > 0 -- Ensure we only consider valid, positive prices\n  ) distinct_prices_per_day_gpu_name\n  GROUP BY 1, 2 -- Group by SaleDate, \"GPU_Name\"\n),\n\n-- Step 1: Combine base tables and add listing_type\nlistings_base AS (\n  SELECT\n    MessageDateTime, MessageID, \"GPU_Name\", GPU_Model, Price, MSRP, AIB,\n    'regular' AS listing_type\n  FROM gpu_data.gpu\n  WHERE \"GPU_Name\" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')\n  -- Note: Price filtering for calculations will happen in later CTEs where averages are computed\n),\n\n-- Step 2: Enrich listings with common calculations and time gap\nlistings_enriched AS (\n  SELECT\n    lb.*,\n    DATE_TRUNC('week', lb.MessageDateTime) AS week,\n    DATE_TRUNC('day', lb.MessageDateTime) AS SaleDate, -- Add SaleDate for joining\n    EXTRACT(DOW FROM lb.MessageDateTime) AS day_of_week,\n    CASE WHEN EXTRACT(DOW FROM lb.MessageDateTime) IN (0, 6) THEN 'weekend' ELSE 'weekday' END AS day_type,\n    CASE\n      WHEN lb.\"GPU_Name\" LIKE 'RTX%' THEN 'NVIDIA'\n      WHEN lb.\"GPU_Name\" LIKE 'RX%' THEN 'AMD'\n      ELSE 'Other'\n    END AS manufacturer,\n    (lb.Price - lb.MSRP < 5 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_msrp,\n    (lb.Price > lb.MSRP * 1.20 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_over_20pct_msrp,\n    (lb.Price - lb.MSRP) AS msrp_delta,\n    EXTRACT(EPOCH FROM (lb.MessageDateTime - LAG(lb.MessageDateTime) OVER (PARTITION BY DATE_TRUNC('week', lb.MessageDateTime), lb.\"GPU_Name\" ORDER BY lb.MessageDateTime))) / 60.0 AS minutes_since_prev -- Partition by GPU_Name too? For per-GPU listing frequency. Or overall as before.\n  FROM listings_base lb\n),\n\n-- Step 3: Calculate weekly average prices (THIS IS THE MAIN CHANGE FOR AVG PRICE)\n-- This CTE will now average the daily unique GPU_Name averages.\nweekly_avg_prices AS (\n  SELECT\n    DATE_TRUNC('week', dgnupa.SaleDate) AS week,\n    AVG(dgnupa.AvgOfUniquePrices) as reg_avg_price_for_calc -- Average of daily averages of unique prices per GPU_Name\n  FROM daily_gpu_name_unique_price_avg dgnupa\n  GROUP BY 1\n),\n\n-- Step 4: Add flags indicating if a listing's PRICE is above the new weekly average\n-- The comparison here is tricky. The weekly_avg_price is an average of daily averages.\n-- Comparing an individual listing's price to this requires careful thought.\n-- For now, I'll keep the structure, but the meaning of 'reg_is_above_avg' changes.\n-- It means: is this specific listing's price higher than the weekly average of (daily averages of unique prices per GPU_Name)?\nlistings_with_avg_comparison AS (\n  SELECT\n    l.*,\n    wap.reg_avg_price_for_calc,\n    (l.Price > wap.reg_avg_price_for_calc AND l.Price IS NOT NULL AND l.Price > 0) as reg_is_above_avg\n  FROM listings_enriched l\n  LEFT JOIN weekly_avg_prices wap ON l.week = wap.week\n),\n\n-- Step 5: Aggregate weekly base statistics using conditional aggregation\nweekly_stats AS (\n  SELECT\n    coalesce(lew.week, wap_main.week) as week, -- Use coalesce if listings_enriched might be empty for a week but daily_gpu_name_unique_price_avg has data\n        \n        -- Counts of listings (unaffected by price filters, taken from listings_enriched)\n        COUNT_IF(lew.listing_type = 'regular') AS reg_num_listings,\n        COUNT_IF(lew.listing_type = 'regular' AND lew.day_type = 'weekday') AS reg_weekday_listings,\n        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'NVIDIA') AS reg_nvidia_listings,\n        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'AMD') AS reg_amd_listings,\n        \n        COUNT_IF(lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_num_listings_with_valid_price,\n\n        -- Pricing aggregates\n        -- reg_avg_price is now sourced from the new weekly_avg_prices CTE (which itself is an avg of daily avgs)\n        MAX(wap_main.reg_avg_price_for_calc) AS reg_avg_price, -- MAX because wap_main is grouped by week\n        \n        -- reg_listed_volume should still sum actual prices of listings\n        SUM(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.Price END) AS reg_listed_volume,\n        \n        -- reg_avg_msrp_delta: this should average the deltas from actual listings\n        AVG(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.msrp_delta END) FILTER (WHERE lew.MSRP IS NOT NULL) AS reg_avg_msrp_delta,\n        \n        COUNT_IF(lew.listing_type = 'regular' AND lew.is_msrp) AS reg_num_msrp_listings,\n        COUNT_IF(lew.listing_type = 'regular' AND lew.is_over_20pct_msrp) AS reg_num_over_20pct_msrp,\n        \n        AVG(CASE WHEN lew.listing_type = 'regular' THEN lew.minutes_since_prev END) AS reg_avg_minutes_between_listings,\n        \n        COUNT_IF(lew.listing_type = 'regular' AND lew.reg_is_above_avg) AS reg_num_above_avg_price,\n        \n        COUNT_IF(lew.listing_type = 'regular' AND lew.MSRP IS NOT NULL AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_total_with_msrp \n\n    FROM listings_with_avg_comparison lew\n    -- FULL JOIN with weekly_avg_prices to ensure weeks with only price data (no listings after filtering) are included for reg_avg_price\n    FULL JOIN weekly_avg_prices wap_main ON lew.week = wap_main.week\n    GROUP BY 1 -- Group by week\n),\n\n-- Step 6: Calculate derived weekly metrics (percentages, ratios)\n-- This CTE should largely remain the same, as it operates on the outputs of weekly_stats\nweekly_stats_derived AS (\n    SELECT\n        *,\n        reg_num_listings / 7.0 AS reg_daily_new_listings,\n        COALESCE(reg_weekday_listings * 1.0 / NULLIF(reg_num_listings, 0), 0) AS reg_weekday_listing_pct,\n        COALESCE(reg_nvidia_listings * 1.0 / NULLIF(reg_amd_listings, 0), NULL) AS reg_nvidia_amd_ratio,\n        COALESCE(reg_num_msrp_listings * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_msrp_listings_pct,\n        COALESCE(reg_num_over_20pct_msrp * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_pct_over_20pct_msrp,\n        COALESCE(reg_num_above_avg_price * 1.0 / NULLIF(reg_num_listings_with_valid_price, 0), 0) AS reg_pct_above_avg_price\n    FROM weekly_stats ws\n),\n\n-- Step 7a: Rank top cards/models for 'regular' listings (Unaffected by price filters)\nreg_top_cards_ranked AS (\n  SELECT\n    week,\n    \"GPU_Name\",\n    COUNT(*) as cnt,\n    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, \"GPU_Name\") as rk\n  FROM listings_enriched -- Counts all listings from enriched base\n  WHERE listing_type = 'regular'\n  GROUP BY week, \"GPU_Name\"\n),\nreg_top_models_ranked AS (\n  SELECT\n    week,\n    GPU_Model,\n    COUNT(*) as cnt,\n    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, GPU_Model) as rk\n  FROM listings_enriched -- Counts all listings from enriched base\n  WHERE listing_type = 'regular' AND GPU_Model IS NOT NULL\n  GROUP BY week, GPU_Model\n),\n\n-- Step 7c: Calculate base MSRP stats per item/level for ranking\nmsrp_stats_base AS (\n  SELECT\n    week, AIB, GPU_Model, \"GPU_Name\",\n    COUNT(*) AS num_msrp_listings\n  FROM listings_enriched\n  WHERE is_msrp AND listing_type = 'regular'\n  GROUP BY week, AIB, GPU_Model, \"GPU_Name\"\n),\nmsrp_total_counts AS (\n  SELECT\n    week, AIB, GPU_Model, \"GPU_Name\",\n    COUNT(*) as total_listings\n  FROM listings_enriched\n  WHERE MSRP IS NOT NULL AND listing_type = 'regular' AND Price IS NOT NULL AND Price > 0\n  GROUP BY week, AIB, GPU_Model, \"GPU_Name\"\n),\nmsrp_stats_agg AS (\n  SELECT\n    tc.week, 'model' as level, tc.GPU_Model as item,\n    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,\n    SUM(tc.total_listings) AS total_listings\n  FROM msrp_total_counts tc\n  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc.\"GPU_Name\" = msb.\"GPU_Name\"\n  WHERE tc.GPU_Model IS NOT NULL\n  GROUP BY tc.week, tc.GPU_Model\n  UNION ALL\n  SELECT\n    tc.week, 'card' as level, tc.\"GPU_Name\" as item,\n    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,\n    SUM(tc.total_listings) AS total_listings\n  FROM msrp_total_counts tc\n  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc.\"GPU_Name\" = msb.\"GPU_Name\"\n  GROUP BY tc.week, tc.\"GPU_Name\"\n),\n\n-- Step 7d: Rank REGULAR MSRP items by percentage\nmsrp_ranked AS (\n  SELECT\n    week, level, item, total_listings,\n    COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) AS msrp_pct,\n    RANK() OVER (PARTITION BY week, level ORDER BY COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) DESC, total_listings DESC, item) as rk\n  FROM msrp_stats_agg\n  WHERE total_listings > 0 \n),\n\n-- Step 8a: Select top cards/models per week\ntop_cards_models AS (\n    SELECT week, MAX(CASE WHEN rk=1 THEN \"GPU_Name\" END) as reg_top_gpu_card\n    FROM reg_top_cards_ranked WHERE rk = 1 GROUP BY week\n),\ntop_models AS (\n     SELECT week, MAX(CASE WHEN rk=1 THEN GPU_Model END) as reg_top_gpu_model\n    FROM reg_top_models_ranked WHERE rk = 1 GROUP BY week\n),\n\n-- Step 8b: Select top MSRP'd items per week\nmost_msrpd AS (\n  SELECT week,\n    MAX(CASE WHEN level = 'model' AND rk = 1 THEN item END) AS reg_most_msrpd_model,\n    MAX(CASE WHEN level = 'card' AND rk = 1 THEN item END) AS reg_most_msrpd_card\n  FROM msrp_ranked\n  WHERE rk = 1\n  GROUP BY week\n),\n\n-- Step 9: Add lagged values for WoW calculation\nweekly_data_with_lag AS (\n  SELECT\n        *,\n        LAG(reg_num_listings, 1) OVER w AS reg_last_week_listing,\n        LAG(reg_weekday_listing_pct, 1) OVER w AS reg_last_weekday_listing_pct,\n        LAG(reg_nvidia_amd_ratio, 1) OVER w AS reg_last_nvidia_amd_ratio,\n        LAG(reg_avg_price, 1) OVER w AS reg_last_week_avg_price,             -- Uses new avg price\n        LAG(reg_pct_above_avg_price, 1) OVER w AS reg_last_pct_above_avg_price, -- Uses new comparison\n        LAG(reg_avg_msrp_delta, 1) OVER w AS reg_last_week_avg_msrp_delta,\n        LAG(reg_num_msrp_listings, 1) OVER w AS reg_last_week_num_msrp_listings,\n        LAG(reg_msrp_listings_pct, 1) OVER w AS reg_last_week_msrp_listings_pct,\n        LAG(reg_pct_over_20pct_msrp, 1) OVER w AS reg_last_pct_over_20pct_msrp,\n        LAG(reg_daily_new_listings, 1) OVER w AS reg_last_week_daily_new_listings,\n        LAG(reg_avg_minutes_between_listings, 1) OVER w AS reg_last_week_avg_minutes_between_listings\n    FROM weekly_stats_derived\n    WINDOW w AS (ORDER BY week ASC)\n)\n\n-- Step 10: Final SELECT with WoW calculations and joins (mostly unchanged structurally)\nSELECT\n    wdl.week,\n    wdl.reg_num_listings AS reg_current_week_listings,\n    wdl.reg_last_week_listing,\n    (wdl.reg_num_listings / NULLIF(wdl.reg_last_week_listing, 0)) - 1 AS reg_wow_pct_listing,\n    wdl.reg_weekday_listing_pct AS reg_current_weekday_listing_pct,\n    wdl.reg_last_weekday_listing_pct,\n    (wdl.reg_weekday_listing_pct / NULLIF(wdl.reg_last_weekday_listing_pct, 0)) - 1 AS reg_wow_weekday_pct,\n    wdl.reg_nvidia_amd_ratio AS reg_current_nvidia_amd_ratio,\n    wdl.reg_last_nvidia_amd_ratio,\n    (wdl.reg_nvidia_amd_ratio / NULLIF(wdl.reg_last_nvidia_amd_ratio, 0)) - 1 AS reg_wow_pct_nvidia_amd_ratio,\n    \n    -- These use the new reg_avg_price calculation\n    wdl.reg_avg_price AS reg_current_week_avg_price,\n    wdl.reg_last_week_avg_price,\n    (wdl.reg_avg_price / NULLIF(wdl.reg_last_week_avg_price, 0)) - 1 AS reg_wow_pct_avg_price,\n    \n    wdl.reg_pct_above_avg_price AS reg_current_pct_above_avg_price,\n    wdl.reg_last_pct_above_avg_price,\n    (wdl.reg_pct_above_avg_price / NULLIF(wdl.reg_last_pct_above_avg_price, 0)) - 1 AS reg_wow_pct_above_avg_price,\n\n    wdl.reg_avg_msrp_delta AS reg_current_week_avg_msrp_delta,\n    wdl.reg_last_week_avg_msrp_delta,\n    CASE WHEN wdl.reg_last_week_avg_msrp_delta IS NULL OR ABS(wdl.reg_last_week_avg_msrp_delta) < 0.01 THEN NULL ELSE (wdl.reg_avg_msrp_delta - wdl.reg_last_week_avg_msrp_delta) / ABS(wdl.reg_last_week_avg_msrp_delta) END AS reg_wow_pct_avg_msrp_delta,\n    wdl.reg_num_msrp_listings AS reg_current_week_num_msrp_listings,\n    wdl.reg_last_week_num_msrp_listings,\n    (wdl.reg_num_msrp_listings / NULLIF(wdl.reg_last_week_num_msrp_listings, 0)) - 1 AS reg_wow_pct_num_msrp_listings,\n    wdl.reg_msrp_listings_pct AS reg_current_week_msrp_listings_pct,\n    wdl.reg_last_week_msrp_listings_pct,\n    (wdl.reg_msrp_listings_pct / NULLIF(wdl.reg_last_week_msrp_listings_pct, 0)) - 1 AS reg_wow_msrp_listings_pct,\n    wdl.reg_pct_over_20pct_msrp AS reg_current_pct_over_20pct_msrp,\n    wdl.reg_last_pct_over_20pct_msrp,\n    (wdl.reg_pct_over_20pct_msrp / NULLIF(wdl.reg_last_pct_over_20pct_msrp, 0)) - 1 AS reg_wow_pct_over_20pct_msrp,\n    wdl.reg_daily_new_listings AS reg_current_week_daily_new_listings,\n    wdl.reg_last_week_daily_new_listings,\n    (wdl.reg_daily_new_listings / NULLIF(wdl.reg_last_week_daily_new_listings, 0)) - 1 AS reg_wow_daily_new_listings,\n    wdl.reg_avg_minutes_between_listings AS reg_current_week_avg_minutes_between_listings,\n    wdl.reg_last_week_avg_minutes_between_listings,\n    (wdl.reg_last_week_avg_minutes_between_listings / NULLIF(wdl.reg_avg_minutes_between_listings, 0)) - 1 AS reg_wow_pct_time_between_listings,\n    COALESCE(tcm.reg_top_gpu_card, 'N/A') AS reg_top_gpu_card,\n    COALESCE(tm.reg_top_gpu_model, 'N/A') AS reg_top_gpu_model,\n    COALESCE(mm.reg_most_msrpd_model, 'N/A') as reg_most_msrpd_model,\n    COALESCE(mm.reg_most_msrpd_card, 'N/A') as reg_most_msrpd_card\nFROM weekly_data_with_lag wdl\nLEFT JOIN top_cards_models tcm ON wdl.week = tcm.week\nLEFT JOIN top_models tm ON wdl.week = tm.week\nLEFT JOIN most_msrpd mm ON wdl.week = mm.week\nORDER BY wdl.week DESC;","inputQueryString":"-- wow_listings\n\n-- Step 0: Calculate daily average of unique prices per GPU_Name\nWITH daily_gpu_name_unique_price_avg AS (\n  SELECT\n    DATE_TRUNC('day', MessageDateTime) AS SaleDate,\n    \"GPU_Name\",\n    AVG(Price) AS AvgOfUniquePrices -- This AVG is over distinct prices for this GPU_Name on this SaleDate\n  FROM (\n    SELECT DISTINCT\n        DATE_TRUNC('day', MessageDateTime) AS SaleDate_inner, -- Renamed to avoid ambiguity in some DBs\n        MessageDateTime, -- Keep original for joining later if needed, or for week calculation\n        \"GPU_Name\",\n        Price\n    FROM gpu_data.gpu\n    WHERE \"GPU_Name\" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')\n      AND Price IS NOT NULL AND Price > 0 -- Ensure we only consider valid, positive prices\n  ) distinct_prices_per_day_gpu_name\n  GROUP BY 1, 2 -- Group by SaleDate, \"GPU_Name\"\n),\n\n-- Step 1: Combine base tables and add listing_type\nlistings_base AS (\n  SELECT\n    MessageDateTime, MessageID, \"GPU_Name\", GPU_Model, Price, MSRP, AIB,\n    'regular' AS listing_type\n  FROM gpu_data.gpu\n  WHERE \"GPU_Name\" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')\n  -- Note: Price filtering for calculations will happen in later CTEs where averages are computed\n),\n\n-- Step 2: Enrich listings with common calculations and time gap\nlistings_enriched AS (\n  SELECT\n    lb.*,\n    DATE_TRUNC('week', lb.MessageDateTime) AS week,\n    DATE_TRUNC('day', lb.MessageDateTime) AS SaleDate, -- Add SaleDate for joining\n    EXTRACT(DOW FROM lb.MessageDateTime) AS day_of_week,\n    CASE WHEN EXTRACT(DOW FROM lb.MessageDateTime) IN (0, 6) THEN 'weekend' ELSE 'weekday' END AS day_type,\n    CASE\n      WHEN lb.\"GPU_Name\" LIKE 'RTX%' THEN 'NVIDIA'\n      WHEN lb.\"GPU_Name\" LIKE 'RX%' THEN 'AMD'\n      ELSE 'Other'\n    END AS manufacturer,\n    (lb.Price - lb.MSRP < 5 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_msrp,\n    (lb.Price > lb.MSRP * 1.20 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_over_20pct_msrp,\n    (lb.Price - lb.MSRP) AS msrp_delta,\n    EXTRACT(EPOCH FROM (lb.MessageDateTime - LAG(lb.MessageDateTime) OVER (PARTITION BY DATE_TRUNC('week', lb.MessageDateTime), lb.\"GPU_Name\" ORDER BY lb.MessageDateTime))) / 60.0 AS minutes_since_prev -- Partition by GPU_Name too? For per-GPU listing frequency. Or overall as before.\n  FROM listings_base lb\n),\n\n-- Step 3: Calculate weekly average prices (THIS IS THE MAIN CHANGE FOR AVG PRICE)\n-- This CTE will now average the daily unique GPU_Name averages.\nweekly_avg_prices AS (\n  SELECT\n    DATE_TRUNC('week', dgnupa.SaleDate) AS week,\n    AVG(dgnupa.AvgOfUniquePrices) as reg_avg_price_for_calc -- Average of daily averages of unique prices per GPU_Name\n  FROM daily_gpu_name_unique_price_avg dgnupa\n  GROUP BY 1\n),\n\n-- Step 4: Add flags indicating if a listing's PRICE is above the new weekly average\n-- The comparison here is tricky. The weekly_avg_price is an average of daily averages.\n-- Comparing an individual listing's price to this requires careful thought.\n-- For now, I'll keep the structure, but the meaning of 'reg_is_above_avg' changes.\n-- It means: is this specific listing's price higher than the weekly average of (daily averages of unique prices per GPU_Name)?\nlistings_with_avg_comparison AS (\n  SELECT\n    l.*,\n    wap.reg_avg_price_for_calc,\n    (l.Price > wap.reg_avg_price_for_calc AND l.Price IS NOT NULL AND l.Price > 0) as reg_is_above_avg\n  FROM listings_enriched l\n  LEFT JOIN weekly_avg_prices wap ON l.week = wap.week\n),\n\n-- Step 5: Aggregate weekly base statistics using conditional aggregation\nweekly_stats AS (\n  SELECT\n    coalesce(lew.week, wap_main.week) as week, -- Use coalesce if listings_enriched might be empty for a week but daily_gpu_name_unique_price_avg has data\n        \n        -- Counts of listings (unaffected by price filters, taken from listings_enriched)\n        COUNT_IF(lew.listing_type = 'regular') AS reg_num_listings,\n        COUNT_IF(lew.listing_type = 'regular' AND lew.day_type = 'weekday') AS reg_weekday_listings,\n        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'NVIDIA') AS reg_nvidia_listings,\n        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'AMD') AS reg_amd_listings,\n        \n        COUNT_IF(lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_num_listings_with_valid_price,\n\n        -- Pricing aggregates\n        -- reg_avg_price is now sourced from the new weekly_avg_prices CTE (which itself is an avg of daily avgs)\n        MAX(wap_main.reg_avg_price_for_calc) AS reg_avg_price, -- MAX because wap_main is grouped by week\n        \n        -- reg_listed_volume should still sum actual prices of listings\n        SUM(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.Price END) AS reg_listed_volume,\n        \n        -- reg_avg_msrp_delta: this should average the deltas from actual listings\n        AVG(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.msrp_delta END) FILTER (WHERE lew.MSRP IS NOT NULL) AS reg_avg_msrp_delta,\n        \n        COUNT_IF(lew.listing_type = 'regular' AND lew.is_msrp) AS reg_num_msrp_listings,\n        COUNT_IF(lew.listing_type = 'regular' AND lew.is_over_20pct_msrp) AS reg_num_over_20pct_msrp,\n        \n        AVG(CASE WHEN lew.listing_type = 'regular' THEN lew.minutes_since_prev END) AS reg_avg_minutes_between_listings,\n        \n        COUNT_IF(lew.listing_type = 'regular' AND lew.reg_is_above_avg) AS reg_num_above_avg_price,\n        \n        COUNT_IF(lew.listing_type = 'regular' AND lew.MSRP IS NOT NULL AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_total_with_msrp \n\n    FROM listings_with_avg_comparison lew\n    -- FULL JOIN with weekly_avg_prices to ensure weeks with only price data (no listings after filtering) are included for reg_avg_price\n    FULL JOIN weekly_avg_prices wap_main ON lew.week = wap_main.week\n    GROUP BY 1 -- Group by week\n),\n\n-- Step 6: Calculate derived weekly metrics (percentages, ratios)\n-- This CTE should largely remain the same, as it operates on the outputs of weekly_stats\nweekly_stats_derived AS (\n    SELECT\n        *,\n        reg_num_listings / 7.0 AS reg_daily_new_listings,\n        COALESCE(reg_weekday_listings * 1.0 / NULLIF(reg_num_listings, 0), 0) AS reg_weekday_listing_pct,\n        COALESCE(reg_nvidia_listings * 1.0 / NULLIF(reg_amd_listings, 0), NULL) AS reg_nvidia_amd_ratio,\n        COALESCE(reg_num_msrp_listings * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_msrp_listings_pct,\n        COALESCE(reg_num_over_20pct_msrp * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_pct_over_20pct_msrp,\n        COALESCE(reg_num_above_avg_price * 1.0 / NULLIF(reg_num_listings_with_valid_price, 0), 0) AS reg_pct_above_avg_price\n    FROM weekly_stats ws\n),\n\n-- Step 7a: Rank top cards/models for 'regular' listings (Unaffected by price filters)\nreg_top_cards_ranked AS (\n  SELECT\n    week,\n    \"GPU_Name\",\n    COUNT(*) as cnt,\n    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, \"GPU_Name\") as rk\n  FROM listings_enriched -- Counts all listings from enriched base\n  WHERE listing_type = 'regular'\n  GROUP BY week, \"GPU_Name\"\n),\nreg_top_models_ranked AS (\n  SELECT\n    week,\n    GPU_Model,\n    COUNT(*) as cnt,\n    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, GPU_Model) as rk\n  FROM listings_enriched -- Counts all listings from enriched base\n  WHERE listing_type = 'regular' AND GPU_Model IS NOT NULL\n  GROUP BY week, GPU_Model\n),\n\n-- Step 7c: Calculate base MSRP stats per item/level for ranking\nmsrp_stats_base AS (\n  SELECT\n    week, AIB, GPU_Model, \"GPU_Name\",\n    COUNT(*) AS num_msrp_listings\n  FROM listings_enriched\n  WHERE is_msrp AND listing_type = 'regular'\n  GROUP BY week, AIB, GPU_Model, \"GPU_Name\"\n),\nmsrp_total_counts AS (\n  SELECT\n    week, AIB, GPU_Model, \"GPU_Name\",\n    COUNT(*) as total_listings\n  FROM listings_enriched\n  WHERE MSRP IS NOT NULL AND listing_type = 'regular' AND Price IS NOT NULL AND Price > 0\n  GROUP BY week, AIB, GPU_Model, \"GPU_Name\"\n),\nmsrp_stats_agg AS (\n  SELECT\n    tc.week, 'model' as level, tc.GPU_Model as item,\n    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,\n    SUM(tc.total_listings) AS total_listings\n  FROM msrp_total_counts tc\n  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc.\"GPU_Name\" = msb.\"GPU_Name\"\n  WHERE tc.GPU_Model IS NOT NULL\n  GROUP BY tc.week, tc.GPU_Model\n  UNION ALL\n  SELECT\n    tc.week, 'card' as level, tc.\"GPU_Name\" as item,\n    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,\n    SUM(tc.total_listings) AS total_listings\n  FROM msrp_total_counts tc\n  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc.\"GPU_Name\" = msb.\"GPU_Name\"\n  GROUP BY tc.week, tc.\"GPU_Name\"\n),\n\n-- Step 7d: Rank REGULAR MSRP items by percentage\nmsrp_ranked AS (\n  SELECT\n    week, level, item, total_listings,\n    COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) AS msrp_pct,\n    RANK() OVER (PARTITION BY week, level ORDER BY COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) DESC, total_listings DESC, item) as rk\n  FROM msrp_stats_agg\n  WHERE total_listings > 0 \n),\n\n-- Step 8a: Select top cards/models per week\ntop_cards_models AS (\n    SELECT week, MAX(CASE WHEN rk=1 THEN \"GPU_Name\" END) as reg_top_gpu_card\n    FROM reg_top_cards_ranked WHERE rk = 1 GROUP BY week\n),\ntop_models AS (\n     SELECT week, MAX(CASE WHEN rk=1 THEN GPU_Model END) as reg_top_gpu_model\n    FROM reg_top_models_ranked WHERE rk = 1 GROUP BY week\n),\n\n-- Step 8b: Select top MSRP'd items per week\nmost_msrpd AS (\n  SELECT week,\n    MAX(CASE WHEN level = 'model' AND rk = 1 THEN item END) AS reg_most_msrpd_model,\n    MAX(CASE WHEN level = 'card' AND rk = 1 THEN item END) AS reg_most_msrpd_card\n  FROM msrp_ranked\n  WHERE rk = 1\n  GROUP BY week\n),\n\n-- Step 9: Add lagged values for WoW calculation\nweekly_data_with_lag AS (\n  SELECT\n        *,\n        LAG(reg_num_listings, 1) OVER w AS reg_last_week_listing,\n        LAG(reg_weekday_listing_pct, 1) OVER w AS reg_last_weekday_listing_pct,\n        LAG(reg_nvidia_amd_ratio, 1) OVER w AS reg_last_nvidia_amd_ratio,\n        LAG(reg_avg_price, 1) OVER w AS reg_last_week_avg_price,             -- Uses new avg price\n        LAG(reg_pct_above_avg_price, 1) OVER w AS reg_last_pct_above_avg_price, -- Uses new comparison\n        LAG(reg_avg_msrp_delta, 1) OVER w AS reg_last_week_avg_msrp_delta,\n        LAG(reg_num_msrp_listings, 1) OVER w AS reg_last_week_num_msrp_listings,\n        LAG(reg_msrp_listings_pct, 1) OVER w AS reg_last_week_msrp_listings_pct,\n        LAG(reg_pct_over_20pct_msrp, 1) OVER w AS reg_last_pct_over_20pct_msrp,\n        LAG(reg_daily_new_listings, 1) OVER w AS reg_last_week_daily_new_listings,\n        LAG(reg_avg_minutes_between_listings, 1) OVER w AS reg_last_week_avg_minutes_between_listings\n    FROM weekly_stats_derived\n    WINDOW w AS (ORDER BY week ASC)\n)\n\n-- Step 10: Final SELECT with WoW calculations and joins (mostly unchanged structurally)\nSELECT\n    wdl.week,\n    wdl.reg_num_listings AS reg_current_week_listings,\n    wdl.reg_last_week_listing,\n    (wdl.reg_num_listings / NULLIF(wdl.reg_last_week_listing, 0)) - 1 AS reg_wow_pct_listing,\n    wdl.reg_weekday_listing_pct AS reg_current_weekday_listing_pct,\n    wdl.reg_last_weekday_listing_pct,\n    (wdl.reg_weekday_listing_pct / NULLIF(wdl.reg_last_weekday_listing_pct, 0)) - 1 AS reg_wow_weekday_pct,\n    wdl.reg_nvidia_amd_ratio AS reg_current_nvidia_amd_ratio,\n    wdl.reg_last_nvidia_amd_ratio,\n    (wdl.reg_nvidia_amd_ratio / NULLIF(wdl.reg_last_nvidia_amd_ratio, 0)) - 1 AS reg_wow_pct_nvidia_amd_ratio,\n    \n    -- These use the new reg_avg_price calculation\n    wdl.reg_avg_price AS reg_current_week_avg_price,\n    wdl.reg_last_week_avg_price,\n    (wdl.reg_avg_price / NULLIF(wdl.reg_last_week_avg_price, 0)) - 1 AS reg_wow_pct_avg_price,\n    \n    wdl.reg_pct_above_avg_price AS reg_current_pct_above_avg_price,\n    wdl.reg_last_pct_above_avg_price,\n    (wdl.reg_pct_above_avg_price / NULLIF(wdl.reg_last_pct_above_avg_price, 0)) - 1 AS reg_wow_pct_above_avg_price,\n\n    wdl.reg_avg_msrp_delta AS reg_current_week_avg_msrp_delta,\n    wdl.reg_last_week_avg_msrp_delta,\n    CASE WHEN wdl.reg_last_week_avg_msrp_delta IS NULL OR ABS(wdl.reg_last_week_avg_msrp_delta) < 0.01 THEN NULL ELSE (wdl.reg_avg_msrp_delta - wdl.reg_last_week_avg_msrp_delta) / ABS(wdl.reg_last_week_avg_msrp_delta) END AS reg_wow_pct_avg_msrp_delta,\n    wdl.reg_num_msrp_listings AS reg_current_week_num_msrp_listings,\n    wdl.reg_last_week_num_msrp_listings,\n    (wdl.reg_num_msrp_listings / NULLIF(wdl.reg_last_week_num_msrp_listings, 0)) - 1 AS reg_wow_pct_num_msrp_listings,\n    wdl.reg_msrp_listings_pct AS reg_current_week_msrp_listings_pct,\n    wdl.reg_last_week_msrp_listings_pct,\n    (wdl.reg_msrp_listings_pct / NULLIF(wdl.reg_last_week_msrp_listings_pct, 0)) - 1 AS reg_wow_msrp_listings_pct,\n    wdl.reg_pct_over_20pct_msrp AS reg_current_pct_over_20pct_msrp,\n    wdl.reg_last_pct_over_20pct_msrp,\n    (wdl.reg_pct_over_20pct_msrp / NULLIF(wdl.reg_last_pct_over_20pct_msrp, 0)) - 1 AS reg_wow_pct_over_20pct_msrp,\n    wdl.reg_daily_new_listings AS reg_current_week_daily_new_listings,\n    wdl.reg_last_week_daily_new_listings,\n    (wdl.reg_daily_new_listings / NULLIF(wdl.reg_last_week_daily_new_listings, 0)) - 1 AS reg_wow_daily_new_listings,\n    wdl.reg_avg_minutes_between_listings AS reg_current_week_avg_minutes_between_listings,\n    wdl.reg_last_week_avg_minutes_between_listings,\n    (wdl.reg_last_week_avg_minutes_between_listings / NULLIF(wdl.reg_avg_minutes_between_listings, 0)) - 1 AS reg_wow_pct_time_between_listings,\n    COALESCE(tcm.reg_top_gpu_card, 'N/A') AS reg_top_gpu_card,\n    COALESCE(tm.reg_top_gpu_model, 'N/A') AS reg_top_gpu_model,\n    COALESCE(mm.reg_most_msrpd_model, 'N/A') as reg_most_msrpd_model,\n    COALESCE(mm.reg_most_msrpd_card, 'N/A') as reg_most_msrpd_card\nFROM weekly_data_with_lag wdl\nLEFT JOIN top_cards_models tcm ON wdl.week = tcm.week\nLEFT JOIN top_models tm ON wdl.week = tm.week\nLEFT JOIN most_msrpd mm ON wdl.week = mm.week\nORDER BY wdl.week DESC;","compiled":false,"inline":true},{"id":"daily_listings_by_manufacturer","compiledQueryString":"WITH listings_base AS (\n    SELECT\n        MessageDateTime,\n        strftime(MessageDateTime, '%a') AS dayweek,\n        MessageID,\n        Manufacturer,\n        'regular' AS listing_type\n    FROM gpu_data.gpu\n    -- FROM gpu_messages\n    WHERE MessageDateTime >= (CURRENT_DATE - INTERVAL '37 days')\n\n)\n\nSELECT\n    dayweek,\n    Manufacturer,\n    COUNT(DISTINCT MessageID) FILTER (WHERE listing_type = 'regular') AS regular_listing_count\nFROM listings_base\nGROUP BY\n    dayweek,\n    Manufacturer\nORDER BY\n    CASE\n        WHEN dayweek = 'Mon' THEN 1\n        WHEN dayweek = 'Tue' THEN 2\n        WHEN dayweek = 'Wed' THEN 3\n        WHEN dayweek = 'Thu' THEN 4\n        WHEN dayweek = 'Fri' THEN 5\n        WHEN dayweek = 'Sat' THEN 6\n        WHEN dayweek = 'Sun' THEN 7\n    END ASC,\n    Manufacturer ASC;","inputQueryString":"WITH listings_base AS (\n    SELECT\n        MessageDateTime,\n        strftime(MessageDateTime, '%a') AS dayweek,\n        MessageID,\n        Manufacturer,\n        'regular' AS listing_type\n    FROM gpu_data.gpu\n    -- FROM gpu_messages\n    WHERE MessageDateTime >= (CURRENT_DATE - INTERVAL '37 days')\n\n)\n\nSELECT\n    dayweek,\n    Manufacturer,\n    COUNT(DISTINCT MessageID) FILTER (WHERE listing_type = 'regular') AS regular_listing_count\nFROM listings_base\nGROUP BY\n    dayweek,\n    Manufacturer\nORDER BY\n    CASE\n        WHEN dayweek = 'Mon' THEN 1\n        WHEN dayweek = 'Tue' THEN 2\n        WHEN dayweek = 'Wed' THEN 3\n        WHEN dayweek = 'Thu' THEN 4\n        WHEN dayweek = 'Fri' THEN 5\n        WHEN dayweek = 'Sat' THEN 6\n        WHEN dayweek = 'Sun' THEN 7\n    END ASC,\n    Manufacturer ASC;","compiled":false,"inline":true}]}