import{s as Ee,t as Je,d as c,u as je,v as Ke,w as Qe,b as k,i as S,a as V,e as M,x as Y,k as I,f as we,q as pe,C as Le,D as ue,g as Se,E as de,U as Nt,c as P,j as D,H as Ft,V as se,W as Te,h as Ht,l as kt,m as Wt,o as Bt,n as Vt,p as Yt}from"../chunks/scheduler.cXSv0lVe.js";import{S as Ne,i as ke,t as d,a as p,g as j,e as K,d as L,m as b,c as O,b as U}from"../chunks/index.DpaiaTSd.js";import{H as ce,g as Ct,J as qe,K as Pt,L as Xt,h as qt,M as Dt,k as vt,V as $t,N as Mt,O as ze,Q as x,R as Ze,S as xe,U as et,W as Jt,X as jt,I as Kt,Y as $e,Z as Qt,_ as zt,e as Zt,s as xt,p as e_,r as Tt,C as t_}from"../chunks/VennDiagram.svelte_svelte_type_style_lang.DA4ZRk1x.js";import{w as __}from"../chunks/entry.BjlFL1GI.js";import{A as s_}from"../chunks/Alert.jnOkoBxs.js";import{h as Xe}from"../chunks/setTrackProxy.Cyfckp0w.js";import{p as r_}from"../chunks/stores.BplvGxAk.js";import{H as a_,Q as It}from"../chunks/Heatmap.CaaG-x27.js";import{p as i_}from"../chunks/profile.BW8tN6E9.js";function l_(a){let e,_,t,r;const s=a[2].default,i=Je(s,a,a[1],null);return{c(){e=I("div"),_=I("span"),i&&i.c(),this.h()},l(n){e=M(n,"DIV",{class:!0});var g=Y(e);_=M(g,"SPAN",{});var m=Y(_);i&&i.l(m),m.forEach(c),g.forEach(c),this.h()},h(){k(e,"class",t=ce("block text-xs text-gray-500 leading-none mt-0 pb-3 not-prose",a[0]))},m(n,g){S(n,e,g),V(e,_),i&&i.m(_,null),r=!0},p(n,[g]){i&&i.p&&(!r||g&2)&&je(i,s,n,n[1],r?Qe(s,n[1],g,null):Ke(n[1]),null),(!r||g&1&&t!==(t=ce("block text-xs text-gray-500 leading-none mt-0 pb-3 not-prose",n[0])))&&k(e,"class",t)},i(n){r||(p(i,n),r=!0)},o(n){d(i,n),r=!1},d(n){n&&c(e),i&&i.d(n)}}}function n_(a,e,_){let{$$slots:t={},$$scope:r}=e,{class:s=void 0}=e;return a.$$set=i=>{"class"in i&&_(0,s=i.class),"$$scope"in i&&_(1,r=i.$$scope)},[s,r,t]}class g_ extends Ne{constructor(e){super(),ke(this,e,n_,l_,Ee,{class:0})}}function m_(a){let e,_;return e=new $t({props:{error:a[3]}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&8&&(s.error=t[3]),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function o_(a){let e,_=vt(a[2],a[4])+"",t,r,s,i=a[1]&&yt(a);return{c(){e=I("span"),t=de(_),r=D(),i&&i.c(),this.h()},l(n){e=M(n,"SPAN",{style:!0});var g=Y(e);t=ue(g,_),r=P(g),i&&i.l(g),g.forEach(c),this.h()},h(){Nt(e,"color",a[5])},m(n,g){S(n,e,g),V(e,t),V(e,r),i&&i.m(e,null),s=!0},p(n,g){(!s||g&20)&&_!==(_=vt(n[2],n[4])+"")&&Le(t,_),n[1]?i?(i.p(n,g),g&2&&p(i,1)):(i=yt(n),i.c(),p(i,1),i.m(e,null)):i&&(j(),d(i,1,1,()=>{i=null}),K()),(!s||g&32)&&Nt(e,"color",n[5])},i(n){s||(p(i),s=!0)},o(n){d(i),s=!1},d(n){n&&c(e),i&&i.d()}}}function c_(a){let e,_,t,r,s,i="Placeholder: no data currently referenced.";return{c(){e=I("span"),_=de("["),t=de(a[0]),r=de("]"),s=I("span"),s.textContent=i,this.h()},l(n){e=M(n,"SPAN",{class:!0});var g=Y(e);_=ue(g,"["),t=ue(g,a[0]),r=ue(g,"]"),s=M(g,"SPAN",{class:!0,"data-svelte-h":!0}),Se(s)!=="svelte-ddarzq"&&(s.textContent=i),g.forEach(c),this.h()},h(){k(s,"class","error-msg svelte-1mb9o01"),k(e,"class","placeholder svelte-1mb9o01")},m(n,g){S(n,e,g),V(e,_),V(e,t),V(e,r),V(e,s)},p(n,g){g&1&&Le(t,n[0])},i:pe,o:pe,d(n){n&&c(e)}}}function yt(a){let e,_;return e=new Mt({props:{description:a[1]}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&2&&(s.description=t[1]),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function p_(a){let e,_,t,r;const s=[c_,o_,m_],i=[];function n(g,m){return g[0]?0:g[3]?2:1}return e=n(a),_=i[e]=s[e](a),{c(){_.c(),t=we()},l(g){_.l(g),t=we()},m(g,m){i[e].m(g,m),S(g,t,m),r=!0},p(g,[m]){let w=e;e=n(g),e===w?i[e].p(g,m):(j(),d(i[w],1,1,()=>{i[w]=null}),K(),_=i[e],_?_.p(g,m):(_=i[e]=s[e](g),_.c()),p(_,1),_.m(t.parentNode,t))},i(g){r||(p(_),r=!0)},o(g){d(_),r=!1},d(g){g&&c(t),i[e].d(g)}}}function u_(a,e,_){let t,r,s=pe,i=()=>(s(),s=Ft(t,v=>_(15,r=v)),t);a.$$.on_destroy.push(()=>s());const{resolveColor:n}=Ct();let{data:g=null}=e,{row:m=0}=e,{column:w=null}=e,{value:u=null}=e,{placeholder:E=null}=e,{description:N=void 0}=e,{fmt:y=void 0}=e,G,F,H,{color:T=void 0}=e,h="",{redNegatives:f=!1}=e,R;return a.$$set=v=>{"data"in v&&_(7,g=v.data),"row"in v&&_(10,m=v.row),"column"in v&&_(8,w=v.column),"value"in v&&_(11,u=v.value),"placeholder"in v&&_(0,E=v.placeholder),"description"in v&&_(1,N=v.description),"fmt"in v&&_(12,y=v.fmt),"color"in v&&_(13,T=v.color),"redNegatives"in v&&_(9,f=v.redNegatives)},a.$$.update=()=>{var v;if(a.$$.dirty&2304&&_(8,w=w??u),a.$$.dirty&21897)try{if(_(3,H=void 0),!E)if(g){if(typeof g=="string")throw Error(`Received: data=${g}, expected: data={${g}}`);if(Array.isArray(g)||_(7,g=[g]),isNaN(m))throw Error("row must be a number (row="+m+")");try{Object.keys(g[m])[0]}catch{throw Error("Row "+m+" does not exist in the dataset")}_(8,w=w??Object.keys(g[m])[0]),qe(g,[w]),_(14,R=Pt(g,"array"));const X=R.filter(C=>{var J;return C.type==="date"&&!(((J=g[0])==null?void 0:J[C.id])instanceof Date)}).map(C=>C.id);for(let C=0;C<X.length;C++)_(7,g=Xt(g,X[C]));_(2,F=g[m][w]),_(14,R=R.filter(C=>C.id===w)),y?_(4,G=qt(y,(v=R[0].format)==null?void 0:v.valueType)):_(4,G=R[0].format)}else throw Error("No data provided. If you referenced a query result, check that the name is correct.")}catch(X){if(_(3,H=X.message),console.error("\x1B[31m%s\x1B[0m",`Error in Value: ${H}`),Dt)throw H}a.$$.dirty&2304&&u&&w&&console.warn('Both "value" and "column" were supplied as props to Value. "value" will be ignored.'),a.$$.dirty&8192&&i(_(6,t=n(T))),a.$$.dirty&512&&_(9,f=f==="true"||f===!0),a.$$.dirty&33284&&(f||r)&&(f&&F<0?_(5,h="rgb(220 38 38)"):r&&_(5,h=r))},[E,N,F,H,G,h,t,g,w,f,m,u,y,T,R,r]}class d_ extends Ne{constructor(e){super(),ke(this,e,u_,p_,Ee,{data:7,row:10,column:8,value:11,placeholder:0,description:1,fmt:12,color:13,redNegatives:9})}}function w_(a){let e;const _=a[7].default,t=Je(_,a,a[8],null);return{c(){t&&t.c()},l(r){t&&t.l(r)},m(r,s){t&&t.m(r,s),e=!0},p(r,s){t&&t.p&&(!e||s&256)&&je(t,_,r,r[8],e?Qe(_,r[8],s,null):Ke(r[8]),null)},i(r){e||(p(t,r),e=!0)},o(r){d(t,r),e=!1},d(r){t&&t.d(r)}}}function f_(a){let e,_;const t=[a[4],{data:x.isQuery(a[11])?Array.from(a[11]):a[11]}];let r={$$slots:{default:[w_]},$$scope:{ctx:a}};for(let s=0;s<t.length;s+=1)r=se(r,t[s]);return e=new d_({props:r}),{c(){U(e.$$.fragment)},l(s){O(e.$$.fragment,s)},m(s,i){b(e,s,i),_=!0},p(s,i){const n=i&2064?Ze(t,[i&16&&xe(s[4]),i&2048&&{data:x.isQuery(s[11])?Array.from(s[11]):s[11]}]):{};i&256&&(n.$$scope={dirty:i,ctx:s}),e.$set(n)},i(s){_||(p(e.$$.fragment,s),_=!0)},o(s){d(e.$$.fragment,s),_=!1},d(s){L(e,s)}}}function Rt(a){let e,_;return e=new et({props:{emptyMessage:a[2],emptySet:a[1],chartType:N_,isInitial:a[3]}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&4&&(s.emptyMessage=t[2]),r&2&&(s.emptySet=t[1]),r&8&&(s.isInitial=t[3]),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function A_(a){let e,_,t=!a[4].placeholder&&Rt(a);return{c(){e=I("span"),t&&t.c(),this.h()},l(r){e=M(r,"SPAN",{slot:!0});var s=Y(e);t&&t.l(s),s.forEach(c),this.h()},h(){k(e,"slot","empty")},m(r,s){S(r,e,s),t&&t.m(e,null),_=!0},p(r,s){r[4].placeholder?t&&(j(),d(t,1,1,()=>{t=null}),K()):t?(t.p(r,s),s&16&&p(t,1)):(t=Rt(r),t.c(),p(t,1),t.m(e,null))},i(r){_||(p(t),_=!0)},o(r){d(t),_=!1},d(r){r&&c(e),t&&t.d()}}}function S_(a){let e,_="Loading...";return{c(){e=I("span"),e.textContent=_,this.h()},l(t){e=M(t,"SPAN",{slot:!0,class:!0,"data-svelte-h":!0}),Se(e)!=="svelte-89gxhc"&&(e.textContent=_),this.h()},h(){k(e,"slot","skeleton"),k(e,"class","text-base-content-muted")},m(t,r){S(t,e,r)},p:pe,d(t){t&&c(e)}}}function E_(a){let e,_;return e=new ze({props:{data:a[0],$$slots:{skeleton:[S_],empty:[A_],default:[f_,({loaded:t})=>({11:t}),({loaded:t})=>t?2048:0]},$$scope:{ctx:a}}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,[r]){const s={};r&1&&(s.data=t[0]),r&2334&&(s.$$scope={dirty:r,ctx:t}),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}let N_="Value";function k_(a,e,_){let t,{$$slots:r={},$$scope:s}=e,{data:i}=e,{column:n}=e,{agg:g}=e;const m=x.isQuery(i)?i.hash:void 0;let w=(i==null?void 0:i.hash)===m,{emptySet:u=void 0}=e,{emptyMessage:E=void 0}=e;return a.$$set=N=>{_(10,e=se(se({},e),Te(N))),"data"in N&&_(0,i=N.data),"column"in N&&_(5,n=N.column),"agg"in N&&_(6,g=N.agg),"emptySet"in N&&_(1,u=N.emptySet),"emptyMessage"in N&&_(2,E=N.emptyMessage),"$$scope"in N&&_(8,s=N.$$scope)},a.$$.update=()=>{a.$$.dirty&97&&g&&_(0,i=i.groupBy(void 0).agg({[g]:{col:n,as:n}})),a.$$.dirty&1&&_(3,w=(i==null?void 0:i.hash)===m),_(4,t=Object.fromEntries(Object.entries(e).filter(([,N])=>N!==void 0)))},e=Te(e),[i,u,E,w,t,n,g,r,s]}class ye extends Ne{constructor(e){super(),ke(this,e,k_,E_,Ee,{data:0,column:5,agg:6,emptySet:1,emptyMessage:2})}}function v_(a){let e;const _=a[6].default,t=Je(_,a,a[7],null);return{c(){t&&t.c()},l(r){t&&t.l(r)},m(r,s){t&&t.m(r,s),e=!0},p(r,s){t&&t.p&&(!e||s&128)&&je(t,_,r,r[7],e?Qe(_,r[7],s,null):Ke(r[7]),null)},i(r){e||(p(t,r),e=!0)},o(r){d(t,r),e=!1},d(r){t&&t.d(r)}}}function T_(a){let e,_;const t=[a[4],{data:x.isQuery(a[10])?Array.from(a[10]):a[10]},{queryID:a[5]}];let r={$$slots:{default:[v_]},$$scope:{ctx:a}};for(let s=0;s<t.length;s+=1)r=se(r,t[s]);return e=new Jt({props:r}),{c(){U(e.$$.fragment)},l(s){O(e.$$.fragment,s)},m(s,i){b(e,s,i),_=!0},p(s,i){const n=i&1072?Ze(t,[i&16&&xe(s[4]),i&1024&&{data:x.isQuery(s[10])?Array.from(s[10]):s[10]},i&32&&{queryID:s[5]}]):{};i&128&&(n.$$scope={dirty:i,ctx:s}),e.$set(n)},i(s){_||(p(e.$$.fragment,s),_=!0)},o(s){d(e.$$.fragment,s),_=!1},d(s){L(e,s)}}}function y_(a){let e,_;return e=new et({props:{slot:"empty",emptyMessage:a[2],emptySet:a[1],chartType:a[4].chartType,isInitial:a[3]}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&4&&(s.emptyMessage=t[2]),r&2&&(s.emptySet=t[1]),r&16&&(s.chartType=t[4].chartType),r&8&&(s.isInitial=t[3]),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function R_(a){let e,_;return e=new jt({props:{slot:"error",title:b_,error:a[10].error.message}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&1024&&(s.error=t[10].error.message),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function L_(a){let e,_;return e=new ze({props:{data:a[0],$$slots:{error:[R_,({loaded:t})=>({10:t}),({loaded:t})=>t?1024:0],empty:[y_],default:[T_,({loaded:t})=>({10:t}),({loaded:t})=>t?1024:0]},$$scope:{ctx:a}}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,[r]){const s={};r&1&&(s.data=t[0]),r&1182&&(s.$$scope={dirty:r,ctx:t}),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}let b_="Sparkline";function O_(a,e,_){let t,{$$slots:r={},$$scope:s}=e,{data:i}=e;const n=x.isQuery(i)?i.hash:void 0;let g=(i==null?void 0:i.hash)===n,{emptySet:m=void 0}=e,{emptyMessage:w=void 0}=e,u=i==null?void 0:i.id;return a.$$set=E=>{_(9,e=se(se({},e),Te(E))),"data"in E&&_(0,i=E.data),"emptySet"in E&&_(1,m=E.emptySet),"emptyMessage"in E&&_(2,w=E.emptyMessage),"$$scope"in E&&_(7,s=E.$$scope)},a.$$.update=()=>{a.$$.dirty&1&&_(3,g=(i==null?void 0:i.hash)===n),_(4,t={...Object.fromEntries(Object.entries(e).filter(([,E])=>E!==void 0))})},e=Te(e),[i,m,w,g,t,u,r,s]}class U_ extends Ne{constructor(e){super(),ke(this,e,O_,L_,Ee,{data:0,emptySet:1,emptyMessage:2})}}function h_(a){let e,_,t,r,s,i,n,g,m,w,u,E,N,y=a[23]&&Lt(a);const G=[D_,P_],F=[];function H(f,R){return f[22]?0:1}n=H(a),g=F[n]=G[n](a);let T=a[8]&&bt(a),h=a[7]&&Ot(a);return{c(){e=I("p"),_=de(a[3]),t=D(),y&&y.c(),s=D(),i=I("div"),g.c(),m=D(),T&&T.c(),u=D(),h&&h.c(),E=we(),this.h()},l(f){e=M(f,"P",{class:!0});var R=Y(e);_=ue(R,a[3]),t=P(R),y&&y.l(R),R.forEach(c),s=P(f),i=M(f,"DIV",{class:!0});var v=Y(i);g.l(v),m=P(v),T&&T.l(v),v.forEach(c),u=P(f),h&&h.l(f),E=we(),this.h()},h(){k(e,"class",r=ce("text-sm align-top leading-none",a[19])),k(i,"class",w=ce("relative text-xl font-medium mt-1.5",a[20]))},m(f,R){S(f,e,R),V(e,_),V(e,t),y&&y.m(e,null),S(f,s,R),S(f,i,R),F[n].m(i,null),V(i,m),T&&T.m(i,null),S(f,u,R),h&&h.m(f,R),S(f,E,R),N=!0},p(f,R){(!N||R&8)&&Le(_,f[3]),f[23]?y?(y.p(f,R),R&8388608&&p(y,1)):(y=Lt(f),y.c(),p(y,1),y.m(e,null)):y&&(j(),d(y,1,1,()=>{y=null}),K()),(!N||R&524288&&r!==(r=ce("text-sm align-top leading-none",f[19])))&&k(e,"class",r);let v=n;n=H(f),n===v?F[n].p(f,R):(j(),d(F[v],1,1,()=>{F[v]=null}),K(),g=F[n],g?g.p(f,R):(g=F[n]=G[n](f),g.c()),p(g,1),g.m(i,m)),f[8]?T?(T.p(f,R),R&256&&p(T,1)):(T=bt(f),T.c(),p(T,1),T.m(i,null)):T&&(j(),d(T,1,1,()=>{T=null}),K()),(!N||R&1048576&&w!==(w=ce("relative text-xl font-medium mt-1.5",f[20])))&&k(i,"class",w),f[7]?h?(h.p(f,R),R&128&&p(h,1)):(h=Ot(f),h.c(),p(h,1),h.m(E.parentNode,E)):h&&(j(),d(h,1,1,()=>{h=null}),K())},i(f){N||(p(y),p(g),p(T),p(h),N=!0)},o(f){d(y),d(g),d(T),d(h),N=!1},d(f){f&&(c(e),c(s),c(i),c(u),c(E)),y&&y.d(),F[n].d(),T&&T.d(),h&&h.d(f)}}}function C_(a){let e,_;return e=new Kt({props:{inputType:"BigValue",error:a[24],width:"148",height:"28"}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&16777216&&(s.error=t[24]),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function Lt(a){let e,_;return e=new Mt({props:{description:a[23],size:"3"}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&8388608&&(s.description=t[23]),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function P_(a){let e,_;return e=new ye({props:{data:a[0],column:a[6],fmt:a[13]}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&1&&(s.data=t[0]),r&64&&(s.column=t[6]),r&8192&&(s.fmt=t[13]),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function D_(a){let e,_,t,r;return _=new ye({props:{data:a[0],column:a[6],fmt:a[13]}}),{c(){e=I("a"),U(_.$$.fragment),this.h()},l(s){e=M(s,"A",{class:!0,href:!0});var i=Y(e);O(_.$$.fragment,i),i.forEach(c),this.h()},h(){k(e,"class","hover:bg-base-200"),k(e,"href",t=$e(a[22]))},m(s,i){S(s,e,i),b(_,e,null),r=!0},p(s,i){const n={};i&1&&(n.data=s[0]),i&64&&(n.column=s[6]),i&8192&&(n.fmt=s[13]),_.$set(n),(!r||i&4194304&&t!==(t=$e(s[22])))&&k(e,"href",t)},i(s){r||(p(_.$$.fragment,s),r=!0)},o(s){d(_.$$.fragment,s),r=!1},d(s){s&&c(e),L(_)}}}function bt(a){let e,_;return e=new U_({props:{height:"15",data:a[0],dateCol:a[8],valueCol:a[6],type:a[9],interactive:"true",color:a[25],valueFmt:a[13]??a[10],dateFmt:a[11],yScale:a[2],connectGroup:a[12]}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&1&&(s.data=t[0]),r&256&&(s.dateCol=t[8]),r&64&&(s.valueCol=t[6]),r&512&&(s.type=t[9]),r&33554432&&(s.color=t[25]),r&9216&&(s.valueFmt=t[13]??t[10]),r&2048&&(s.dateFmt=t[11]),r&4&&(s.yScale=t[2]),r&4096&&(s.connectGroup=t[12]),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function Ot(a){let e,_,t,r;const s=[I_,M_],i=[];function n(g,m){return g[1]?0:1}return e=n(a),_=i[e]=s[e](a),{c(){_.c(),t=we()},l(g){_.l(g),t=we()},m(g,m){i[e].m(g,m),S(g,t,m),r=!0},p(g,m){let w=e;e=n(g),e===w?i[e].p(g,m):(j(),d(i[w],1,1,()=>{i[w]=null}),K(),_=i[e],_?_.p(g,m):(_=i[e]=s[e](g),_.c()),p(_,1),_.m(t.parentNode,t))},i(g){r||(p(_),r=!0)},o(g){d(_),r=!1},d(g){g&&c(t),i[e].d(g)}}}function M_(a){let e,_,t,r,s,i,n;const g=[F_,G_],m=[];function w(u,E){return u[22]?0:1}return _=w(a),t=m[_]=g[_](a),{c(){e=I("p"),t.c(),r=D(),s=I("span"),i=de(a[4]),this.h()},l(u){e=M(u,"P",{class:!0});var E=Y(e);t.l(E),r=P(E),s=M(E,"SPAN",{});var N=Y(s);i=ue(N,a[4]),N.forEach(c),E.forEach(c),this.h()},h(){k(e,"class","text-xs font-sans /60 pt-[0.5px]")},m(u,E){S(u,e,E),m[_].m(e,null),V(e,r),V(e,s),V(s,i),n=!0},p(u,E){let N=_;_=w(u),_===N?m[_].p(u,E):(j(),d(m[N],1,1,()=>{m[N]=null}),K(),t=m[_],t?t.p(u,E):(t=m[_]=g[_](u),t.c()),p(t,1),t.m(e,r)),(!n||E&16)&&Le(i,u[4])},i(u){n||(p(t),n=!0)},o(u){d(t),n=!1},d(u){u&&c(e),m[_].d()}}}function I_(a){let e,_,t,r;return _=new Qt({props:{data:a[0],column:a[7],fmt:a[14],fontClass:"text-xs",symbolPosition:"left",neutralMin:a[15],neutralMax:a[16],text:a[4],downIsGood:a[5]}}),{c(){e=I("p"),U(_.$$.fragment),this.h()},l(s){e=M(s,"P",{class:!0});var i=Y(e);O(_.$$.fragment,i),i.forEach(c),this.h()},h(){k(e,"class",t=ce("text-xs font-sans mt-1",a[21]))},m(s,i){S(s,e,i),b(_,e,null),r=!0},p(s,i){const n={};i&1&&(n.data=s[0]),i&128&&(n.column=s[7]),i&16384&&(n.fmt=s[14]),i&32768&&(n.neutralMin=s[15]),i&65536&&(n.neutralMax=s[16]),i&16&&(n.text=s[4]),i&32&&(n.downIsGood=s[5]),_.$set(n),(!r||i&2097152&&t!==(t=ce("text-xs font-sans mt-1",s[21])))&&k(e,"class",t)},i(s){r||(p(_.$$.fragment,s),r=!0)},o(s){d(_.$$.fragment,s),r=!1},d(s){s&&c(e),L(_)}}}function G_(a){let e,_;return e=new ye({props:{data:a[0],column:a[7],fmt:a[14]}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&1&&(s.data=t[0]),r&128&&(s.column=t[7]),r&16384&&(s.fmt=t[14]),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function F_(a){let e,_,t,r;return _=new ye({props:{data:a[0],column:a[7],fmt:a[14]}}),{c(){e=I("a"),U(_.$$.fragment),this.h()},l(s){e=M(s,"A",{class:!0,href:!0});var i=Y(e);O(_.$$.fragment,i),i.forEach(c),this.h()},h(){k(e,"class","hover:bg-base-200"),k(e,"href",t=$e(a[22]))},m(s,i){S(s,e,i),b(_,e,null),r=!0},p(s,i){const n={};i&1&&(n.data=s[0]),i&128&&(n.column=s[7]),i&16384&&(n.fmt=s[14]),_.$set(n),(!r||i&4194304&&t!==(t=$e(s[22])))&&k(e,"href",t)},i(s){r||(p(_.$$.fragment,s),r=!0)},o(s){d(_.$$.fragment,s),r=!1},d(s){s&&c(e),L(_)}}}function H_(a){let e,_,t,r,s;const i=[C_,h_],n=[];function g(m,w){return m[24].length>0?0:1}return _=g(a),t=n[_]=i[_](a),{c(){e=I("div"),t.c(),this.h()},l(m){e=M(m,"DIV",{class:!0,style:!0});var w=Y(e);t.l(w),w.forEach(c),this.h()},h(){k(e,"class","inline-block font-sans pt-2 pb-3 pl-0 mr-3 items-center align-top"),k(e,"style",r=`
        min-width: ${a[18]};
        max-width: ${a[17]};
		`)},m(m,w){S(m,e,w),n[_].m(e,null),s=!0},p(m,[w]){let u=_;_=g(m),_===u?n[_].p(m,w):(j(),d(n[u],1,1,()=>{n[u]=null}),K(),t=n[_],t?t.p(m,w):(t=n[_]=i[_](m),t.c()),p(t,1),t.m(e,null)),(!s||w&393216&&r!==(r=`
        min-width: ${m[18]};
        max-width: ${m[17]};
		`))&&k(e,"style",r)},i(m){s||(p(t),s=!0)},o(m){d(t),s=!1},d(m){m&&c(e),n[_].d()}}}function W_(a,e,_){let t;const{resolveColor:r}=Ct();let{data:s}=e,{value:i=null}=e,{comparison:n=null}=e,{comparisonDelta:g=!0}=e,{sparkline:m=null}=e,{sparklineType:w="line"}=e,{sparklineColor:u=void 0}=e,{sparklineValueFmt:E=void 0}=e,{sparklineDateFmt:N=void 0}=e,{sparklineYScale:y=!1}=e,{connectGroup:G=void 0}=e,{fmt:F=void 0}=e,{comparisonFmt:H=void 0}=e,{title:T=null}=e,{comparisonTitle:h=null}=e,{downIsGood:f=!1}=e,{neutralMin:R=0}=e,{neutralMax:v=0}=e,{maxWidth:X="none"}=e,{minWidth:C="18%"}=e,{titleClass:J=void 0}=e,{valueClass:Q=void 0}=e,{comparisonClass:fe=void 0}=e,{link:z=null}=e,{description:Ae=void 0}=e,$=[];return a.$$set=A=>{"data"in A&&_(0,s=A.data),"value"in A&&_(6,i=A.value),"comparison"in A&&_(7,n=A.comparison),"comparisonDelta"in A&&_(1,g=A.comparisonDelta),"sparkline"in A&&_(8,m=A.sparkline),"sparklineType"in A&&_(9,w=A.sparklineType),"sparklineColor"in A&&_(26,u=A.sparklineColor),"sparklineValueFmt"in A&&_(10,E=A.sparklineValueFmt),"sparklineDateFmt"in A&&_(11,N=A.sparklineDateFmt),"sparklineYScale"in A&&_(2,y=A.sparklineYScale),"connectGroup"in A&&_(12,G=A.connectGroup),"fmt"in A&&_(13,F=A.fmt),"comparisonFmt"in A&&_(14,H=A.comparisonFmt),"title"in A&&_(3,T=A.title),"comparisonTitle"in A&&_(4,h=A.comparisonTitle),"downIsGood"in A&&_(5,f=A.downIsGood),"neutralMin"in A&&_(15,R=A.neutralMin),"neutralMax"in A&&_(16,v=A.neutralMax),"maxWidth"in A&&_(17,X=A.maxWidth),"minWidth"in A&&_(18,C=A.minWidth),"titleClass"in A&&_(19,J=A.titleClass),"valueClass"in A&&_(20,Q=A.valueClass),"comparisonClass"in A&&_(21,fe=A.comparisonClass),"link"in A&&_(22,z=A.link),"description"in A&&_(23,Ae=A.description)},a.$$.update=()=>{if(a.$$.dirty&2&&_(1,g=g==="true"||g===!0),a.$$.dirty&67108864&&_(25,t=r(u)),a.$$.dirty&4&&_(2,y=y==="true"||y===!0),a.$$.dirty&32&&_(5,f=f==="true"||f===!0),a.$$.dirty&16777689)try{Array.isArray(s)||_(0,s=[s]),qe(s,[i]);let A=Pt(s,"array"),Z=A.find(ee=>ee.id===i);if(_(3,T=T??(Z?Z.title:null)),n!==null){qe(s,[n]);let ee=A.find(ve=>ve.id===n);_(4,h=h??(ee?ee.title:null))}m!==null&&qe(s,[m])}catch(A){if(_(24,$=[...$,A]),Dt)throw $}},[s,g,y,T,h,f,i,n,m,w,E,N,G,F,H,R,v,X,C,J,Q,fe,z,Ae,$,t,u]}let B_=class extends Ne{constructor(e){super(),ke(this,e,W_,H_,Ee,{data:0,value:6,comparison:7,comparisonDelta:1,sparkline:8,sparklineType:9,sparklineColor:26,sparklineValueFmt:10,sparklineDateFmt:11,sparklineYScale:2,connectGroup:12,fmt:13,comparisonFmt:14,title:3,comparisonTitle:4,downIsGood:5,neutralMin:15,neutralMax:16,maxWidth:17,minWidth:18,titleClass:19,valueClass:20,comparisonClass:21,link:22,description:23})}};function V_(a){let e;const _=a[6].default,t=Je(_,a,a[7],null);return{c(){t&&t.c()},l(r){t&&t.l(r)},m(r,s){t&&t.m(r,s),e=!0},p(r,s){t&&t.p&&(!e||s&128)&&je(t,_,r,r[7],e?Qe(_,r[7],s,null):Ke(r[7]),null)},i(r){e||(p(t,r),e=!0)},o(r){d(t,r),e=!1},d(r){t&&t.d(r)}}}function Y_(a){let e,_;const t=[a[4],{data:x.isQuery(a[9])?Array.from(a[9]):a[9]}];let r={$$slots:{default:[V_]},$$scope:{ctx:a}};for(let s=0;s<t.length;s+=1)r=se(r,t[s]);return e=new B_({props:r}),{c(){U(e.$$.fragment)},l(s){O(e.$$.fragment,s)},m(s,i){b(e,s,i),_=!0},p(s,i){const n=i&528?Ze(t,[i&16&&xe(s[4]),i&512&&{data:x.isQuery(s[9])?Array.from(s[9]):s[9]}]):{};i&128&&(n.$$scope={dirty:i,ctx:s}),e.$set(n)},i(s){_||(p(e.$$.fragment,s),_=!0)},o(s){d(e.$$.fragment,s),_=!1},d(s){L(e,s)}}}function X_(a){let e,_,t,r;return _=new zt({props:{error:a[9].error.message}}),{c(){e=I("div"),U(_.$$.fragment),this.h()},l(s){e=M(s,"DIV",{slot:!0,class:!0,style:!0});var i=Y(e);O(_.$$.fragment,i),i.forEach(c),this.h()},h(){k(e,"slot","error"),k(e,"class","inline-block font-sans pt-2 pb-3 pr-3 pl-0 mr-3 items-center align-top"),k(e,"style",t=`
				min-width: ${a[5].minWidth};
				max-width: ${a[5].maxWidth};
		`)},m(s,i){S(s,e,i),b(_,e,null),r=!0},p(s,i){const n={};i&512&&(n.error=s[9].error.message),_.$set(n),(!r||i&32&&t!==(t=`
				min-width: ${s[5].minWidth};
				max-width: ${s[5].maxWidth};
		`))&&k(e,"style",t)},i(s){r||(p(_.$$.fragment,s),r=!0)},o(s){d(_.$$.fragment,s),r=!1},d(s){s&&c(e),L(_)}}}function q_(a){let e,_,t,r;return _=new et({props:{emptyMessage:a[2],emptySet:a[1],chartType:j_,isInitial:a[3]}}),{c(){e=I("div"),U(_.$$.fragment),this.h()},l(s){e=M(s,"DIV",{slot:!0,class:!0,style:!0});var i=Y(e);O(_.$$.fragment,i),i.forEach(c),this.h()},h(){k(e,"slot","empty"),k(e,"class","inline-block font-sans pt-2 pb-3 pr-3 pl-0 mr-3 items-center align-top"),k(e,"style",t=`
				min-width: ${a[5].minWidth};
				max-width: ${a[5].maxWidth};
		`)},m(s,i){S(s,e,i),b(_,e,null),r=!0},p(s,i){const n={};i&4&&(n.emptyMessage=s[2]),i&2&&(n.emptySet=s[1]),i&8&&(n.isInitial=s[3]),_.$set(n),(!r||i&32&&t!==(t=`
				min-width: ${s[5].minWidth};
				max-width: ${s[5].maxWidth};
		`))&&k(e,"style",t)},i(s){r||(p(_.$$.fragment,s),r=!0)},o(s){d(_.$$.fragment,s),r=!1},d(s){s&&c(e),L(_)}}}function $_(a){let e,_,t=(a[5].title??" ")+"",r,s,i,n,g;return i=new ye({props:{column:a[5].value,fmt:a[5].fmt,data:a[9]}}),{c(){e=I("div"),_=I("p"),r=de(t),s=D(),U(i.$$.fragment),this.h()},l(m){e=M(m,"DIV",{class:!0,style:!0,slot:!0});var w=Y(e);_=M(w,"P",{class:!0});var u=Y(_);r=ue(u,t),u.forEach(c),s=P(w),O(i.$$.fragment,w),w.forEach(c),this.h()},h(){k(_,"class","text-sm"),k(e,"class","inline-block font-sans pt-2 pb-3 pr-3 pl-0 mr-3 items-center align-top"),k(e,"style",n=`
			min-width: ${a[5].minWidth};
			max-width: ${a[5].maxWidth};
		`),k(e,"slot","skeleton")},m(m,w){S(m,e,w),V(e,_),V(_,r),V(e,s),b(i,e,null),g=!0},p(m,w){(!g||w&32)&&t!==(t=(m[5].title??" ")+"")&&Le(r,t);const u={};w&32&&(u.column=m[5].value),w&32&&(u.fmt=m[5].fmt),w&512&&(u.data=m[9]),i.$set(u),(!g||w&32&&n!==(n=`
			min-width: ${m[5].minWidth};
			max-width: ${m[5].maxWidth};
		`))&&k(e,"style",n)},i(m){g||(p(i.$$.fragment,m),g=!0)},o(m){d(i.$$.fragment,m),g=!1},d(m){m&&c(e),L(i)}}}function J_(a){let e,_;return e=new ze({props:{data:a[0],$$slots:{skeleton:[$_,({loaded:t})=>({9:t}),({loaded:t})=>t?512:0],empty:[q_],error:[X_,({loaded:t})=>({9:t}),({loaded:t})=>t?512:0],default:[Y_,({loaded:t})=>({9:t}),({loaded:t})=>t?512:0]},$$scope:{ctx:a}}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,[r]){const s={};r&1&&(s.data=t[0]),r&702&&(s.$$scope={dirty:r,ctx:t}),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}let j_="Big Value";function K_(a,e,_){let t,{$$slots:r={},$$scope:s}=e,{data:i}=e;const n=x.isQuery(i)?i.hash:void 0;let g=(i==null?void 0:i.hash)===n,{emptySet:m=void 0}=e,{emptyMessage:w=void 0}=e;return a.$$set=u=>{_(5,e=se(se({},e),Te(u))),"data"in u&&_(0,i=u.data),"emptySet"in u&&_(1,m=u.emptySet),"emptyMessage"in u&&_(2,w=u.emptyMessage),"$$scope"in u&&_(7,s=u.$$scope)},a.$$.update=()=>{a.$$.dirty&1&&_(3,g=(i==null?void 0:i.hash)===n),_(4,t=Object.fromEntries(Object.entries(e).filter(([,u])=>u!==void 0)))},e=Te(e),[i,m,w,g,t,e,r,s]}class q extends Ne{constructor(e){super(),ke(this,e,K_,J_,Ee,{data:0,emptySet:1,emptyMessage:2})}}function Q_(a){return{c(){this.h()},l(e){this.h()},h(){document.title="Evidence"},m:pe,p:pe,d:pe}}function z_(a){let e,_,t;return _=new ye({props:{data:a[0],column:"week",fmt:"MMM D, YYYY"}}),{c(){e=de("Latest data for week of "),U(_.$$.fragment)},l(r){e=ue(r,"Latest data for week of "),O(_.$$.fragment,r)},m(r,s){S(r,e,s),b(_,r,s),t=!0},p(r,s){const i={};s&1&&(i.data=r[0]),_.$set(i)},i(r){t||(p(_.$$.fragment,r),t=!0)},o(r){d(_.$$.fragment,r),t=!1},d(r){r&&c(e),L(_,r)}}}function Z_(a){let e,_='<p class="font-bold">Note</p> <p>This dashboard analyzes data from GPU restock tracking communities. The key metric, <strong>Restock Alerts</strong>, serves as a proxy for market scarcity.</p> <ul class="list-disc pl-5"><li><strong>A high number of alerts</strong> suggests volatile supply and high demand, as products sell out quickly.</li> <li><strong>A low number of alerts</strong> suggests supply is stabilizing and products are more readily available, reducing the need for notifications.</li></ul> <p>Therefore, a decrease in weekly alerts is generally a positive sign of a healthier, more accessible market for consumers.</p>';return{c(){e=I("div"),e.innerHTML=_,this.h()},l(t){e=M(t,"DIV",{class:!0,"data-svelte-h":!0}),Se(e)!=="svelte-yo94hn"&&(e.innerHTML=_),this.h()},h(){k(e,"class","text-xs")},m(t,r){S(t,e,r)},p:pe,d(t){t&&c(e)}}}function Ut(a){let e,_;return e=new It({props:{queryID:"wow_listings",queryResult:a[0]}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&1&&(s.queryResult=t[0]),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function ht(a){let e,_;return e=new It({props:{queryID:"daily_listings_by_manufacturer",queryResult:a[1]}}),{c(){U(e.$$.fragment)},l(t){O(e.$$.fragment,t)},m(t,r){b(e,t,r),_=!0},p(t,r){const s={};r&2&&(s.queryResult=t[1]),e.$set(s)},i(t){_||(p(e.$$.fragment,t),_=!0)},o(t){d(e.$$.fragment,t),_=!1},d(t){L(e,t)}}}function x_(a){let e,_,t,r,s,i,n='<a href="#weekly-summary">Weekly Summary</a>',g,m,w,u,E,N,y,G,F='<a href="#restock-alerts-analysis">Restock Alerts Analysis</a>',H,T,h,f,R,v,X,C,J,Q,fe,z,Ae,$,A,Z,ee,ve,be,Oe,te,tt='<a href="#price-analysis">Price Analysis</a>',Ue,re,he,ae,Ce,ie,Pe,De,Me,Ie,Ge,_e,_t='<a href="#msrp-analysis">MSRP Analysis</a>',Fe,le,He,ne,We,ge,Be,me,Ve,oe,Ye;function Gt(l,o){return Q_}let Re=Gt()(a);m=new g_({props:{$$slots:{default:[z_]},$$scope:{ctx:a}}}),u=new s_({props:{status:"info",$$slots:{default:[Z_]},$$scope:{ctx:a}}});let W=a[0]&&Ut(a),B=a[1]&&ht(a);return T=new q({props:{data:a[0],title:"Total # of Restock Alerts",value:"reg_current_week_listings",sparkline:"week",sparklineType:"area",comparison:"reg_wow_pct_listing",comparisonFmt:"pct1",comparisonTitle:"vs. Last Week",description:"Total number of in-stock alerts from tracked retailers. A downward trend indicates improving product availability.",connectGroup:"weekly-reg"}}),f=new q({props:{title:"Avg # of Daily Alerts",data:a[0],value:"reg_current_week_daily_new_listings",sparkline:"week",sparklineType:"area",comparison:"reg_wow_daily_new_listings",comparisonFmt:"pct1",comparisonTitle:"vs. Last Week",description:"Average new in-stock alerts per day. A lower number suggests supply is meeting demand more consistently.",connectGroup:"weekly-reg"}}),v=new a_({props:{data:a[1],x:"dayweek",y:"Manufacturer",value:"regular_listing_count",valueFmt:"number0",title:"Restock Alerts by day of week",colorScale:["#EFF3FF","#08306B"]}}),C=new q({props:{title:"Weekday Alert %",data:a[0],value:"reg_current_weekday_listing_pct",fmt:"pct1",sparkline:"week",sparklineType:"area",comparison:"reg_wow_weekday_pct",comparisonFmt:"pct1",comparisonTitle:"vs. Last Week",description:"% of alerts that occur Mon-Fri, indicating when retailers most often restock.",connectGroup:"weekly-reg"}}),Q=new q({props:{title:"Avg Mins b/w Alerts",data:a[0],value:"reg_current_week_avg_minutes_between_listings",fmt:"number0",sparkline:"week",sparklineType:"area",comparison:"reg_wow_pct_time_between_listings",comparisonFmt:"pct1",comparisonTitle:"vs. Last Week",description:"Average time between consecutive alerts. A longer time suggests less frantic, more stable restocking patterns.",connectGroup:"weekly-reg"}}),z=new q({props:{title:"NVIDIA / AMD Alert Ratio",data:a[0],value:"reg_current_nvidia_amd_ratio",fmt:"number2",sparkline:"week",sparklineType:"area",comparison:"reg_wow_pct_nvidia_amd_ratio",comparisonFmt:"pct1",comparisonTitle:"vs. Last Week",description:"Ratio of NVIDIA alerts to AMD alerts, showing relative supply volatility between the two brands.",connectGroup:"weekly-reg"}}),$=new q({props:{title:"Most Frequent Alert: Card",data:a[0],value:"reg_top_gpu_card",fmt:"text",description:"The GPU card that triggered the most restock alerts this week, indicating it may be in high demand or have sporadic supply.",connectGroup:"weekly-reg"}}),Z=new q({props:{title:"Most Frequent Alert: Model",data:a[0],value:"reg_top_gpu_model",fmt:"text",description:"The specific GPU model that triggered the most restock alerts this week.",connectGroup:"weekly-reg"}}),re=new q({props:{title:"Avg Price",data:a[0],value:"reg_current_week_avg_price",fmt:"usd0",sparkline:"week",sparklineType:"area",comparison:"reg_wow_pct_avg_price",comparisonFmt:"pct1",comparisonTitle:"vs. Last Week",description:"Average price across all listings",connectGroup:"weekly-reg"}}),ae=new q({props:{title:"Avg MSRP Premium",data:a[0],value:"reg_current_week_avg_msrp_delta",fmt:"usd0",sparkline:"week",sparklineType:"area",comparison:"reg_wow_pct_avg_msrp_delta",comparisonFmt:"pct1",comparisonTitle:"vs. Last Week",description:"Average dollar amount above MSRP for items that triggered a restock alert.",connectGroup:"weekly-reg"}}),ie=new q({props:{title:"% Listings > Avg Price",data:a[0],value:"reg_current_pct_above_avg_price",fmt:"pct1",sparkline:"week",sparklineType:"area",comparison:"reg_wow_pct_above_avg_price",comparisonFmt:"pct1",comparisonTitle:"vs. Last Week",description:"Percentage of listings priced higher than the weekly average",connectGroup:"weekly-reg"}}),le=new q({props:{title:"# of MSRP Alerts",data:a[0],value:"reg_current_week_num_msrp_listings",sparkline:"week",sparklineType:"area",comparison:"reg_wow_pct_num_msrp_listings",comparisonFmt:"pct1",comparisonTitle:"vs. Last Week",description:"Number of alerts for products priced at or near their MSRP.",connectGroup:"weekly-reg"}}),ne=new q({props:{title:"MSRP Alert Share",data:a[0],value:"reg_current_week_msrp_listings_pct",fmt:"pct1",sparkline:"week",sparklineType:"area",comparison:"reg_wow_msrp_listings_pct",comparisonFmt:"pct1",comparisonTitle:"vs. Last Week",description:"% of all alerts that were for products priced at or near MSRP.",connectGroup:"weekly-reg"}}),ge=new q({props:{title:"% Listings >20% Above MSRP",data:a[0],value:"reg_current_pct_over_20pct_msrp",fmt:"pct1",sparkline:"week",sparklineType:"area",comparison:"reg_wow_pct_over_20pct_msrp",comparisonFmt:"pct1",comparisonTitle:"vs. Last Week",description:"% of listings priced significantly (>20%) over MSRP",connectGroup:"weekly-reg"}}),me=new q({props:{title:"Most MSRP'd Model",data:a[0],value:"reg_most_msrpd_model",fmt:"text",description:"Specific model with highest % listings <= MSRP",connectGroup:"weekly-reg"}}),oe=new q({props:{title:"Most MSRP'd Card",data:a[0],value:"reg_most_msrpd_card",fmt:"text",description:"Base card with highest % listings <= MSRP",connectGroup:"weekly-reg"}}),{c(){e=D(),Re.c(),_=I("meta"),t=I("meta"),r=we(),s=D(),i=I("h1"),i.innerHTML=n,g=D(),U(m.$$.fragment),w=D(),U(u.$$.fragment),E=D(),W&&W.c(),N=D(),B&&B.c(),y=D(),G=I("h2"),G.innerHTML=F,H=D(),U(T.$$.fragment),h=D(),U(f.$$.fragment),R=D(),U(v.$$.fragment),X=D(),U(C.$$.fragment),J=D(),U(Q.$$.fragment),fe=D(),U(z.$$.fragment),Ae=D(),U($.$$.fragment),A=D(),U(Z.$$.fragment),ee=D(),ve=I("br"),be=I("br"),Oe=D(),te=I("h2"),te.innerHTML=tt,Ue=D(),U(re.$$.fragment),he=D(),U(ae.$$.fragment),Ce=D(),U(ie.$$.fragment),Pe=D(),De=I("br"),Me=D(),Ie=I("br"),Ge=D(),_e=I("h2"),_e.innerHTML=_t,Fe=D(),U(le.$$.fragment),He=D(),U(ne.$$.fragment),We=D(),U(ge.$$.fragment),Be=D(),U(me.$$.fragment),Ve=D(),U(oe.$$.fragment),this.h()},l(l){e=P(l);const o=Ht("svelte-2igo1p",document.head);Re.l(o),_=M(o,"META",{name:!0,content:!0}),t=M(o,"META",{name:!0,content:!0}),r=we(),o.forEach(c),s=P(l),i=M(l,"H1",{class:!0,id:!0,"data-svelte-h":!0}),Se(i)!=="svelte-1bsfpf5"&&(i.innerHTML=n),g=P(l),O(m.$$.fragment,l),w=P(l),O(u.$$.fragment,l),E=P(l),W&&W.l(l),N=P(l),B&&B.l(l),y=P(l),G=M(l,"H2",{class:!0,id:!0,"data-svelte-h":!0}),Se(G)!=="svelte-3n3j72"&&(G.innerHTML=F),H=P(l),O(T.$$.fragment,l),h=P(l),O(f.$$.fragment,l),R=P(l),O(v.$$.fragment,l),X=P(l),O(C.$$.fragment,l),J=P(l),O(Q.$$.fragment,l),fe=P(l),O(z.$$.fragment,l),Ae=P(l),O($.$$.fragment,l),A=P(l),O(Z.$$.fragment,l),ee=P(l),ve=M(l,"BR",{}),be=M(l,"BR",{}),Oe=P(l),te=M(l,"H2",{class:!0,id:!0,"data-svelte-h":!0}),Se(te)!=="svelte-13okjun"&&(te.innerHTML=tt),Ue=P(l),O(re.$$.fragment,l),he=P(l),O(ae.$$.fragment,l),Ce=P(l),O(ie.$$.fragment,l),Pe=P(l),De=M(l,"BR",{}),Me=P(l),Ie=M(l,"BR",{}),Ge=P(l),_e=M(l,"H2",{class:!0,id:!0,"data-svelte-h":!0}),Se(_e)!=="svelte-1sl16yy"&&(_e.innerHTML=_t),Fe=P(l),O(le.$$.fragment,l),He=P(l),O(ne.$$.fragment,l),We=P(l),O(ge.$$.fragment,l),Be=P(l),O(me.$$.fragment,l),Ve=P(l),O(oe.$$.fragment,l),this.h()},h(){k(_,"name","twitter:card"),k(_,"content","summary_large_image"),k(t,"name","twitter:site"),k(t,"content","@evidence_dev"),k(i,"class","markdown"),k(i,"id","weekly-summary"),k(G,"class","markdown"),k(G,"id","restock-alerts-analysis"),k(te,"class","markdown"),k(te,"id","price-analysis"),k(_e,"class","markdown"),k(_e,"id","msrp-analysis")},m(l,o){S(l,e,o),Re.m(document.head,null),V(document.head,_),V(document.head,t),V(document.head,r),S(l,s,o),S(l,i,o),S(l,g,o),b(m,l,o),S(l,w,o),b(u,l,o),S(l,E,o),W&&W.m(l,o),S(l,N,o),B&&B.m(l,o),S(l,y,o),S(l,G,o),S(l,H,o),b(T,l,o),S(l,h,o),b(f,l,o),S(l,R,o),b(v,l,o),S(l,X,o),b(C,l,o),S(l,J,o),b(Q,l,o),S(l,fe,o),b(z,l,o),S(l,Ae,o),b($,l,o),S(l,A,o),b(Z,l,o),S(l,ee,o),S(l,ve,o),S(l,be,o),S(l,Oe,o),S(l,te,o),S(l,Ue,o),b(re,l,o),S(l,he,o),b(ae,l,o),S(l,Ce,o),b(ie,l,o),S(l,Pe,o),S(l,De,o),S(l,Me,o),S(l,Ie,o),S(l,Ge,o),S(l,_e,o),S(l,Fe,o),b(le,l,o),S(l,He,o),b(ne,l,o),S(l,We,o),b(ge,l,o),S(l,Be,o),b(me,l,o),S(l,Ve,o),b(oe,l,o),Ye=!0},p(l,[o]){Re.p(l,o);const st={};o&16777217&&(st.$$scope={dirty:o,ctx:l}),m.$set(st);const rt={};o&16777216&&(rt.$$scope={dirty:o,ctx:l}),u.$set(rt),l[0]?W?(W.p(l,o),o&1&&p(W,1)):(W=Ut(l),W.c(),p(W,1),W.m(N.parentNode,N)):W&&(j(),d(W,1,1,()=>{W=null}),K()),l[1]?B?(B.p(l,o),o&2&&p(B,1)):(B=ht(l),B.c(),p(B,1),B.m(y.parentNode,y)):B&&(j(),d(B,1,1,()=>{B=null}),K());const at={};o&1&&(at.data=l[0]),T.$set(at);const it={};o&1&&(it.data=l[0]),f.$set(it);const lt={};o&2&&(lt.data=l[1]),v.$set(lt);const nt={};o&1&&(nt.data=l[0]),C.$set(nt);const gt={};o&1&&(gt.data=l[0]),Q.$set(gt);const mt={};o&1&&(mt.data=l[0]),z.$set(mt);const ot={};o&1&&(ot.data=l[0]),$.$set(ot);const ct={};o&1&&(ct.data=l[0]),Z.$set(ct);const pt={};o&1&&(pt.data=l[0]),re.$set(pt);const ut={};o&1&&(ut.data=l[0]),ae.$set(ut);const dt={};o&1&&(dt.data=l[0]),ie.$set(dt);const wt={};o&1&&(wt.data=l[0]),le.$set(wt);const ft={};o&1&&(ft.data=l[0]),ne.$set(ft);const At={};o&1&&(At.data=l[0]),ge.$set(At);const St={};o&1&&(St.data=l[0]),me.$set(St);const Et={};o&1&&(Et.data=l[0]),oe.$set(Et)},i(l){Ye||(p(m.$$.fragment,l),p(u.$$.fragment,l),p(W),p(B),p(T.$$.fragment,l),p(f.$$.fragment,l),p(v.$$.fragment,l),p(C.$$.fragment,l),p(Q.$$.fragment,l),p(z.$$.fragment,l),p($.$$.fragment,l),p(Z.$$.fragment,l),p(re.$$.fragment,l),p(ae.$$.fragment,l),p(ie.$$.fragment,l),p(le.$$.fragment,l),p(ne.$$.fragment,l),p(ge.$$.fragment,l),p(me.$$.fragment,l),p(oe.$$.fragment,l),Ye=!0)},o(l){d(m.$$.fragment,l),d(u.$$.fragment,l),d(W),d(B),d(T.$$.fragment,l),d(f.$$.fragment,l),d(v.$$.fragment,l),d(C.$$.fragment,l),d(Q.$$.fragment,l),d(z.$$.fragment,l),d($.$$.fragment,l),d(Z.$$.fragment,l),d(re.$$.fragment,l),d(ae.$$.fragment,l),d(ie.$$.fragment,l),d(le.$$.fragment,l),d(ne.$$.fragment,l),d(ge.$$.fragment,l),d(me.$$.fragment,l),d(oe.$$.fragment,l),Ye=!1},d(l){l&&(c(e),c(s),c(i),c(g),c(w),c(E),c(N),c(y),c(G),c(H),c(h),c(R),c(X),c(J),c(fe),c(Ae),c(A),c(ee),c(ve),c(be),c(Oe),c(te),c(Ue),c(he),c(Ce),c(Pe),c(De),c(Me),c(Ie),c(Ge),c(_e),c(Fe),c(He),c(We),c(Be),c(Ve)),Re.d(l),c(_),c(t),c(r),L(m,l),L(u,l),W&&W.d(l),B&&B.d(l),L(T,l),L(f,l),L(v,l),L(C,l),L(Q,l),L(z,l),L($,l),L(Z,l),L(re,l),L(ae,l),L(ie,l),L(le,l),L(ne,l),L(ge,l),L(me,l),L(oe,l)}}}function es(a,e,_){let t,r;kt(a,r_,C=>_(12,t=C)),kt(a,Tt,C=>_(18,r=C));let{data:s}=e,{data:i={},customFormattingSettings:n,__db:g,inputs:m}=s;Wt(Tt,r="418e5bcc133fa0105155a9a026b09ab5",r);let w=Zt(__(m));Bt(w.subscribe(C=>m=C)),Vt(t_,{getCustomFormats:()=>n.customFormats||[]});const u=(C,J)=>i_(g.query,C,{query_name:J});xt(u),t.params,Yt(()=>!0);let E={initialData:void 0,initialError:void 0},N=Xe`-- wow_listings

-- Step 0: Calculate daily average of unique prices per GPU_Name
WITH daily_gpu_name_unique_price_avg AS (
  SELECT
    DATE_TRUNC('day', MessageDateTime) AS SaleDate,
    "GPU_Name",
    AVG(Price) AS AvgOfUniquePrices -- This AVG is over distinct prices for this GPU_Name on this SaleDate
  FROM (
    SELECT DISTINCT
        DATE_TRUNC('day', MessageDateTime) AS SaleDate_inner, -- Renamed to avoid ambiguity in some DBs
        MessageDateTime, -- Keep original for joining later if needed, or for week calculation
        "GPU_Name",
        Price
    FROM gpu_data.gpu
    WHERE "GPU_Name" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')
      AND Price IS NOT NULL AND Price > 0 -- Ensure we only consider valid, positive prices
  ) distinct_prices_per_day_gpu_name
  GROUP BY 1, 2 -- Group by SaleDate, "GPU_Name"
),

-- Step 1: Combine base tables and add listing_type
listings_base AS (
  SELECT
    MessageDateTime, MessageID, "GPU_Name", GPU_Model, Price, MSRP, AIB,
    'regular' AS listing_type
  FROM gpu_data.gpu
  WHERE "GPU_Name" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')
  -- Note: Price filtering for calculations will happen in later CTEs where averages are computed
),

-- Step 2: Enrich listings with common calculations and time gap
listings_enriched AS (
  SELECT
    lb.*,
    DATE_TRUNC('week', lb.MessageDateTime) AS week,
    DATE_TRUNC('day', lb.MessageDateTime) AS SaleDate, -- Add SaleDate for joining
    EXTRACT(DOW FROM lb.MessageDateTime) AS day_of_week,
    CASE WHEN EXTRACT(DOW FROM lb.MessageDateTime) IN (0, 6) THEN 'weekend' ELSE 'weekday' END AS day_type,
    CASE
      WHEN lb."GPU_Name" LIKE 'RTX%' THEN 'NVIDIA'
      WHEN lb."GPU_Name" LIKE 'RX%' THEN 'AMD'
      ELSE 'Other'
    END AS manufacturer,
    (lb.Price - lb.MSRP < 5 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_msrp,
    (lb.Price > lb.MSRP * 1.20 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_over_20pct_msrp,
    (lb.Price - lb.MSRP) AS msrp_delta,
    EXTRACT(EPOCH FROM (lb.MessageDateTime - LAG(lb.MessageDateTime) OVER (PARTITION BY DATE_TRUNC('week', lb.MessageDateTime), lb."GPU_Name" ORDER BY lb.MessageDateTime))) / 60.0 AS minutes_since_prev -- Partition by GPU_Name too? For per-GPU listing frequency. Or overall as before.
  FROM listings_base lb
),

-- Step 3: Calculate weekly average prices (THIS IS THE MAIN CHANGE FOR AVG PRICE)
-- This CTE will now average the daily unique GPU_Name averages.
weekly_avg_prices AS (
  SELECT
    DATE_TRUNC('week', dgnupa.SaleDate) AS week,
    AVG(dgnupa.AvgOfUniquePrices) as reg_avg_price_for_calc -- Average of daily averages of unique prices per GPU_Name
  FROM daily_gpu_name_unique_price_avg dgnupa
  GROUP BY 1
),

-- Step 4: Add flags indicating if a listing's PRICE is above the new weekly average
-- The comparison here is tricky. The weekly_avg_price is an average of daily averages.
-- Comparing an individual listing's price to this requires careful thought.
-- For now, I'll keep the structure, but the meaning of 'reg_is_above_avg' changes.
-- It means: is this specific listing's price higher than the weekly average of (daily averages of unique prices per GPU_Name)?
listings_with_avg_comparison AS (
  SELECT
    l.*,
    wap.reg_avg_price_for_calc,
    (l.Price > wap.reg_avg_price_for_calc AND l.Price IS NOT NULL AND l.Price > 0) as reg_is_above_avg
  FROM listings_enriched l
  LEFT JOIN weekly_avg_prices wap ON l.week = wap.week
),

-- Step 5: Aggregate weekly base statistics using conditional aggregation
weekly_stats AS (
  SELECT
    coalesce(lew.week, wap_main.week) as week, -- Use coalesce if listings_enriched might be empty for a week but daily_gpu_name_unique_price_avg has data
        
        -- Counts of listings (unaffected by price filters, taken from listings_enriched)
        COUNT_IF(lew.listing_type = 'regular') AS reg_num_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.day_type = 'weekday') AS reg_weekday_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'NVIDIA') AS reg_nvidia_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'AMD') AS reg_amd_listings,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_num_listings_with_valid_price,

        -- Pricing aggregates
        -- reg_avg_price is now sourced from the new weekly_avg_prices CTE (which itself is an avg of daily avgs)
        MAX(wap_main.reg_avg_price_for_calc) AS reg_avg_price, -- MAX because wap_main is grouped by week
        
        -- reg_listed_volume should still sum actual prices of listings
        SUM(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.Price END) AS reg_listed_volume,
        
        -- reg_avg_msrp_delta: this should average the deltas from actual listings
        AVG(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.msrp_delta END) FILTER (WHERE lew.MSRP IS NOT NULL) AS reg_avg_msrp_delta,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.is_msrp) AS reg_num_msrp_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.is_over_20pct_msrp) AS reg_num_over_20pct_msrp,
        
        AVG(CASE WHEN lew.listing_type = 'regular' THEN lew.minutes_since_prev END) AS reg_avg_minutes_between_listings,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.reg_is_above_avg) AS reg_num_above_avg_price,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.MSRP IS NOT NULL AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_total_with_msrp 

    FROM listings_with_avg_comparison lew
    -- FULL JOIN with weekly_avg_prices to ensure weeks with only price data (no listings after filtering) are included for reg_avg_price
    FULL JOIN weekly_avg_prices wap_main ON lew.week = wap_main.week
    GROUP BY 1 -- Group by week
),

-- Step 6: Calculate derived weekly metrics (percentages, ratios)
-- This CTE should largely remain the same, as it operates on the outputs of weekly_stats
weekly_stats_derived AS (
    SELECT
        *,
        reg_num_listings / 7.0 AS reg_daily_new_listings,
        COALESCE(reg_weekday_listings * 1.0 / NULLIF(reg_num_listings, 0), 0) AS reg_weekday_listing_pct,
        COALESCE(reg_nvidia_listings * 1.0 / NULLIF(reg_amd_listings, 0), NULL) AS reg_nvidia_amd_ratio,
        COALESCE(reg_num_msrp_listings * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_msrp_listings_pct,
        COALESCE(reg_num_over_20pct_msrp * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_pct_over_20pct_msrp,
        COALESCE(reg_num_above_avg_price * 1.0 / NULLIF(reg_num_listings_with_valid_price, 0), 0) AS reg_pct_above_avg_price
    FROM weekly_stats ws
),

-- Step 7a: Rank top cards/models for 'regular' listings (Unaffected by price filters)
reg_top_cards_ranked AS (
  SELECT
    week,
    "GPU_Name",
    COUNT(*) as cnt,
    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, "GPU_Name") as rk
  FROM listings_enriched -- Counts all listings from enriched base
  WHERE listing_type = 'regular'
  GROUP BY week, "GPU_Name"
),
reg_top_models_ranked AS (
  SELECT
    week,
    GPU_Model,
    COUNT(*) as cnt,
    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, GPU_Model) as rk
  FROM listings_enriched -- Counts all listings from enriched base
  WHERE listing_type = 'regular' AND GPU_Model IS NOT NULL
  GROUP BY week, GPU_Model
),

-- Step 7c: Calculate base MSRP stats per item/level for ranking
msrp_stats_base AS (
  SELECT
    week, AIB, GPU_Model, "GPU_Name",
    COUNT(*) AS num_msrp_listings
  FROM listings_enriched
  WHERE is_msrp AND listing_type = 'regular'
  GROUP BY week, AIB, GPU_Model, "GPU_Name"
),
msrp_total_counts AS (
  SELECT
    week, AIB, GPU_Model, "GPU_Name",
    COUNT(*) as total_listings
  FROM listings_enriched
  WHERE MSRP IS NOT NULL AND listing_type = 'regular' AND Price IS NOT NULL AND Price > 0
  GROUP BY week, AIB, GPU_Model, "GPU_Name"
),
msrp_stats_agg AS (
  SELECT
    tc.week, 'model' as level, tc.GPU_Model as item,
    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,
    SUM(tc.total_listings) AS total_listings
  FROM msrp_total_counts tc
  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc."GPU_Name" = msb."GPU_Name"
  WHERE tc.GPU_Model IS NOT NULL
  GROUP BY tc.week, tc.GPU_Model
  UNION ALL
  SELECT
    tc.week, 'card' as level, tc."GPU_Name" as item,
    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,
    SUM(tc.total_listings) AS total_listings
  FROM msrp_total_counts tc
  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc."GPU_Name" = msb."GPU_Name"
  GROUP BY tc.week, tc."GPU_Name"
),

-- Step 7d: Rank REGULAR MSRP items by percentage
msrp_ranked AS (
  SELECT
    week, level, item, total_listings,
    COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) AS msrp_pct,
    RANK() OVER (PARTITION BY week, level ORDER BY COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) DESC, total_listings DESC, item) as rk
  FROM msrp_stats_agg
  WHERE total_listings > 0 
),

-- Step 8a: Select top cards/models per week
top_cards_models AS (
    SELECT week, MAX(CASE WHEN rk=1 THEN "GPU_Name" END) as reg_top_gpu_card
    FROM reg_top_cards_ranked WHERE rk = 1 GROUP BY week
),
top_models AS (
     SELECT week, MAX(CASE WHEN rk=1 THEN GPU_Model END) as reg_top_gpu_model
    FROM reg_top_models_ranked WHERE rk = 1 GROUP BY week
),

-- Step 8b: Select top MSRP'd items per week
most_msrpd AS (
  SELECT week,
    MAX(CASE WHEN level = 'model' AND rk = 1 THEN item END) AS reg_most_msrpd_model,
    MAX(CASE WHEN level = 'card' AND rk = 1 THEN item END) AS reg_most_msrpd_card
  FROM msrp_ranked
  WHERE rk = 1
  GROUP BY week
),

-- Step 9: Add lagged values for WoW calculation
weekly_data_with_lag AS (
  SELECT
        *,
        LAG(reg_num_listings, 1) OVER w AS reg_last_week_listing,
        LAG(reg_weekday_listing_pct, 1) OVER w AS reg_last_weekday_listing_pct,
        LAG(reg_nvidia_amd_ratio, 1) OVER w AS reg_last_nvidia_amd_ratio,
        LAG(reg_avg_price, 1) OVER w AS reg_last_week_avg_price,             -- Uses new avg price
        LAG(reg_pct_above_avg_price, 1) OVER w AS reg_last_pct_above_avg_price, -- Uses new comparison
        LAG(reg_avg_msrp_delta, 1) OVER w AS reg_last_week_avg_msrp_delta,
        LAG(reg_num_msrp_listings, 1) OVER w AS reg_last_week_num_msrp_listings,
        LAG(reg_msrp_listings_pct, 1) OVER w AS reg_last_week_msrp_listings_pct,
        LAG(reg_pct_over_20pct_msrp, 1) OVER w AS reg_last_pct_over_20pct_msrp,
        LAG(reg_daily_new_listings, 1) OVER w AS reg_last_week_daily_new_listings,
        LAG(reg_avg_minutes_between_listings, 1) OVER w AS reg_last_week_avg_minutes_between_listings
    FROM weekly_stats_derived
    WINDOW w AS (ORDER BY week ASC)
)

-- Step 10: Final SELECT with WoW calculations and joins (mostly unchanged structurally)
SELECT
    wdl.week,
    wdl.reg_num_listings AS reg_current_week_listings,
    wdl.reg_last_week_listing,
    (wdl.reg_num_listings / NULLIF(wdl.reg_last_week_listing, 0)) - 1 AS reg_wow_pct_listing,
    wdl.reg_weekday_listing_pct AS reg_current_weekday_listing_pct,
    wdl.reg_last_weekday_listing_pct,
    (wdl.reg_weekday_listing_pct / NULLIF(wdl.reg_last_weekday_listing_pct, 0)) - 1 AS reg_wow_weekday_pct,
    wdl.reg_nvidia_amd_ratio AS reg_current_nvidia_amd_ratio,
    wdl.reg_last_nvidia_amd_ratio,
    (wdl.reg_nvidia_amd_ratio / NULLIF(wdl.reg_last_nvidia_amd_ratio, 0)) - 1 AS reg_wow_pct_nvidia_amd_ratio,
    
    -- These use the new reg_avg_price calculation
    wdl.reg_avg_price AS reg_current_week_avg_price,
    wdl.reg_last_week_avg_price,
    (wdl.reg_avg_price / NULLIF(wdl.reg_last_week_avg_price, 0)) - 1 AS reg_wow_pct_avg_price,
    
    wdl.reg_pct_above_avg_price AS reg_current_pct_above_avg_price,
    wdl.reg_last_pct_above_avg_price,
    (wdl.reg_pct_above_avg_price / NULLIF(wdl.reg_last_pct_above_avg_price, 0)) - 1 AS reg_wow_pct_above_avg_price,

    wdl.reg_avg_msrp_delta AS reg_current_week_avg_msrp_delta,
    wdl.reg_last_week_avg_msrp_delta,
    CASE WHEN wdl.reg_last_week_avg_msrp_delta IS NULL OR ABS(wdl.reg_last_week_avg_msrp_delta) < 0.01 THEN NULL ELSE (wdl.reg_avg_msrp_delta - wdl.reg_last_week_avg_msrp_delta) / ABS(wdl.reg_last_week_avg_msrp_delta) END AS reg_wow_pct_avg_msrp_delta,
    wdl.reg_num_msrp_listings AS reg_current_week_num_msrp_listings,
    wdl.reg_last_week_num_msrp_listings,
    (wdl.reg_num_msrp_listings / NULLIF(wdl.reg_last_week_num_msrp_listings, 0)) - 1 AS reg_wow_pct_num_msrp_listings,
    wdl.reg_msrp_listings_pct AS reg_current_week_msrp_listings_pct,
    wdl.reg_last_week_msrp_listings_pct,
    (wdl.reg_msrp_listings_pct / NULLIF(wdl.reg_last_week_msrp_listings_pct, 0)) - 1 AS reg_wow_msrp_listings_pct,
    wdl.reg_pct_over_20pct_msrp AS reg_current_pct_over_20pct_msrp,
    wdl.reg_last_pct_over_20pct_msrp,
    (wdl.reg_pct_over_20pct_msrp / NULLIF(wdl.reg_last_pct_over_20pct_msrp, 0)) - 1 AS reg_wow_pct_over_20pct_msrp,
    wdl.reg_daily_new_listings AS reg_current_week_daily_new_listings,
    wdl.reg_last_week_daily_new_listings,
    (wdl.reg_daily_new_listings / NULLIF(wdl.reg_last_week_daily_new_listings, 0)) - 1 AS reg_wow_daily_new_listings,
    wdl.reg_avg_minutes_between_listings AS reg_current_week_avg_minutes_between_listings,
    wdl.reg_last_week_avg_minutes_between_listings,
    (wdl.reg_last_week_avg_minutes_between_listings / NULLIF(wdl.reg_avg_minutes_between_listings, 0)) - 1 AS reg_wow_pct_time_between_listings,
    COALESCE(tcm.reg_top_gpu_card, 'N/A') AS reg_top_gpu_card,
    COALESCE(tm.reg_top_gpu_model, 'N/A') AS reg_top_gpu_model,
    COALESCE(mm.reg_most_msrpd_model, 'N/A') as reg_most_msrpd_model,
    COALESCE(mm.reg_most_msrpd_card, 'N/A') as reg_most_msrpd_card
FROM weekly_data_with_lag wdl
LEFT JOIN top_cards_models tcm ON wdl.week = tcm.week
LEFT JOIN top_models tm ON wdl.week = tm.week
LEFT JOIN most_msrpd mm ON wdl.week = mm.week
ORDER BY wdl.week DESC;`,y=`-- wow_listings

-- Step 0: Calculate daily average of unique prices per GPU_Name
WITH daily_gpu_name_unique_price_avg AS (
  SELECT
    DATE_TRUNC('day', MessageDateTime) AS SaleDate,
    "GPU_Name",
    AVG(Price) AS AvgOfUniquePrices -- This AVG is over distinct prices for this GPU_Name on this SaleDate
  FROM (
    SELECT DISTINCT
        DATE_TRUNC('day', MessageDateTime) AS SaleDate_inner, -- Renamed to avoid ambiguity in some DBs
        MessageDateTime, -- Keep original for joining later if needed, or for week calculation
        "GPU_Name",
        Price
    FROM gpu_data.gpu
    WHERE "GPU_Name" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')
      AND Price IS NOT NULL AND Price > 0 -- Ensure we only consider valid, positive prices
  ) distinct_prices_per_day_gpu_name
  GROUP BY 1, 2 -- Group by SaleDate, "GPU_Name"
),

-- Step 1: Combine base tables and add listing_type
listings_base AS (
  SELECT
    MessageDateTime, MessageID, "GPU_Name", GPU_Model, Price, MSRP, AIB,
    'regular' AS listing_type
  FROM gpu_data.gpu
  WHERE "GPU_Name" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')
  -- Note: Price filtering for calculations will happen in later CTEs where averages are computed
),

-- Step 2: Enrich listings with common calculations and time gap
listings_enriched AS (
  SELECT
    lb.*,
    DATE_TRUNC('week', lb.MessageDateTime) AS week,
    DATE_TRUNC('day', lb.MessageDateTime) AS SaleDate, -- Add SaleDate for joining
    EXTRACT(DOW FROM lb.MessageDateTime) AS day_of_week,
    CASE WHEN EXTRACT(DOW FROM lb.MessageDateTime) IN (0, 6) THEN 'weekend' ELSE 'weekday' END AS day_type,
    CASE
      WHEN lb."GPU_Name" LIKE 'RTX%' THEN 'NVIDIA'
      WHEN lb."GPU_Name" LIKE 'RX%' THEN 'AMD'
      ELSE 'Other'
    END AS manufacturer,
    (lb.Price - lb.MSRP < 5 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_msrp,
    (lb.Price > lb.MSRP * 1.20 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_over_20pct_msrp,
    (lb.Price - lb.MSRP) AS msrp_delta,
    EXTRACT(EPOCH FROM (lb.MessageDateTime - LAG(lb.MessageDateTime) OVER (PARTITION BY DATE_TRUNC('week', lb.MessageDateTime), lb."GPU_Name" ORDER BY lb.MessageDateTime))) / 60.0 AS minutes_since_prev -- Partition by GPU_Name too? For per-GPU listing frequency. Or overall as before.
  FROM listings_base lb
),

-- Step 3: Calculate weekly average prices (THIS IS THE MAIN CHANGE FOR AVG PRICE)
-- This CTE will now average the daily unique GPU_Name averages.
weekly_avg_prices AS (
  SELECT
    DATE_TRUNC('week', dgnupa.SaleDate) AS week,
    AVG(dgnupa.AvgOfUniquePrices) as reg_avg_price_for_calc -- Average of daily averages of unique prices per GPU_Name
  FROM daily_gpu_name_unique_price_avg dgnupa
  GROUP BY 1
),

-- Step 4: Add flags indicating if a listing's PRICE is above the new weekly average
-- The comparison here is tricky. The weekly_avg_price is an average of daily averages.
-- Comparing an individual listing's price to this requires careful thought.
-- For now, I'll keep the structure, but the meaning of 'reg_is_above_avg' changes.
-- It means: is this specific listing's price higher than the weekly average of (daily averages of unique prices per GPU_Name)?
listings_with_avg_comparison AS (
  SELECT
    l.*,
    wap.reg_avg_price_for_calc,
    (l.Price > wap.reg_avg_price_for_calc AND l.Price IS NOT NULL AND l.Price > 0) as reg_is_above_avg
  FROM listings_enriched l
  LEFT JOIN weekly_avg_prices wap ON l.week = wap.week
),

-- Step 5: Aggregate weekly base statistics using conditional aggregation
weekly_stats AS (
  SELECT
    coalesce(lew.week, wap_main.week) as week, -- Use coalesce if listings_enriched might be empty for a week but daily_gpu_name_unique_price_avg has data
        
        -- Counts of listings (unaffected by price filters, taken from listings_enriched)
        COUNT_IF(lew.listing_type = 'regular') AS reg_num_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.day_type = 'weekday') AS reg_weekday_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'NVIDIA') AS reg_nvidia_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'AMD') AS reg_amd_listings,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_num_listings_with_valid_price,

        -- Pricing aggregates
        -- reg_avg_price is now sourced from the new weekly_avg_prices CTE (which itself is an avg of daily avgs)
        MAX(wap_main.reg_avg_price_for_calc) AS reg_avg_price, -- MAX because wap_main is grouped by week
        
        -- reg_listed_volume should still sum actual prices of listings
        SUM(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.Price END) AS reg_listed_volume,
        
        -- reg_avg_msrp_delta: this should average the deltas from actual listings
        AVG(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.msrp_delta END) FILTER (WHERE lew.MSRP IS NOT NULL) AS reg_avg_msrp_delta,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.is_msrp) AS reg_num_msrp_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.is_over_20pct_msrp) AS reg_num_over_20pct_msrp,
        
        AVG(CASE WHEN lew.listing_type = 'regular' THEN lew.minutes_since_prev END) AS reg_avg_minutes_between_listings,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.reg_is_above_avg) AS reg_num_above_avg_price,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.MSRP IS NOT NULL AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_total_with_msrp 

    FROM listings_with_avg_comparison lew
    -- FULL JOIN with weekly_avg_prices to ensure weeks with only price data (no listings after filtering) are included for reg_avg_price
    FULL JOIN weekly_avg_prices wap_main ON lew.week = wap_main.week
    GROUP BY 1 -- Group by week
),

-- Step 6: Calculate derived weekly metrics (percentages, ratios)
-- This CTE should largely remain the same, as it operates on the outputs of weekly_stats
weekly_stats_derived AS (
    SELECT
        *,
        reg_num_listings / 7.0 AS reg_daily_new_listings,
        COALESCE(reg_weekday_listings * 1.0 / NULLIF(reg_num_listings, 0), 0) AS reg_weekday_listing_pct,
        COALESCE(reg_nvidia_listings * 1.0 / NULLIF(reg_amd_listings, 0), NULL) AS reg_nvidia_amd_ratio,
        COALESCE(reg_num_msrp_listings * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_msrp_listings_pct,
        COALESCE(reg_num_over_20pct_msrp * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_pct_over_20pct_msrp,
        COALESCE(reg_num_above_avg_price * 1.0 / NULLIF(reg_num_listings_with_valid_price, 0), 0) AS reg_pct_above_avg_price
    FROM weekly_stats ws
),

-- Step 7a: Rank top cards/models for 'regular' listings (Unaffected by price filters)
reg_top_cards_ranked AS (
  SELECT
    week,
    "GPU_Name",
    COUNT(*) as cnt,
    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, "GPU_Name") as rk
  FROM listings_enriched -- Counts all listings from enriched base
  WHERE listing_type = 'regular'
  GROUP BY week, "GPU_Name"
),
reg_top_models_ranked AS (
  SELECT
    week,
    GPU_Model,
    COUNT(*) as cnt,
    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, GPU_Model) as rk
  FROM listings_enriched -- Counts all listings from enriched base
  WHERE listing_type = 'regular' AND GPU_Model IS NOT NULL
  GROUP BY week, GPU_Model
),

-- Step 7c: Calculate base MSRP stats per item/level for ranking
msrp_stats_base AS (
  SELECT
    week, AIB, GPU_Model, "GPU_Name",
    COUNT(*) AS num_msrp_listings
  FROM listings_enriched
  WHERE is_msrp AND listing_type = 'regular'
  GROUP BY week, AIB, GPU_Model, "GPU_Name"
),
msrp_total_counts AS (
  SELECT
    week, AIB, GPU_Model, "GPU_Name",
    COUNT(*) as total_listings
  FROM listings_enriched
  WHERE MSRP IS NOT NULL AND listing_type = 'regular' AND Price IS NOT NULL AND Price > 0
  GROUP BY week, AIB, GPU_Model, "GPU_Name"
),
msrp_stats_agg AS (
  SELECT
    tc.week, 'model' as level, tc.GPU_Model as item,
    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,
    SUM(tc.total_listings) AS total_listings
  FROM msrp_total_counts tc
  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc."GPU_Name" = msb."GPU_Name"
  WHERE tc.GPU_Model IS NOT NULL
  GROUP BY tc.week, tc.GPU_Model
  UNION ALL
  SELECT
    tc.week, 'card' as level, tc."GPU_Name" as item,
    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,
    SUM(tc.total_listings) AS total_listings
  FROM msrp_total_counts tc
  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc."GPU_Name" = msb."GPU_Name"
  GROUP BY tc.week, tc."GPU_Name"
),

-- Step 7d: Rank REGULAR MSRP items by percentage
msrp_ranked AS (
  SELECT
    week, level, item, total_listings,
    COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) AS msrp_pct,
    RANK() OVER (PARTITION BY week, level ORDER BY COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) DESC, total_listings DESC, item) as rk
  FROM msrp_stats_agg
  WHERE total_listings > 0 
),

-- Step 8a: Select top cards/models per week
top_cards_models AS (
    SELECT week, MAX(CASE WHEN rk=1 THEN "GPU_Name" END) as reg_top_gpu_card
    FROM reg_top_cards_ranked WHERE rk = 1 GROUP BY week
),
top_models AS (
     SELECT week, MAX(CASE WHEN rk=1 THEN GPU_Model END) as reg_top_gpu_model
    FROM reg_top_models_ranked WHERE rk = 1 GROUP BY week
),

-- Step 8b: Select top MSRP'd items per week
most_msrpd AS (
  SELECT week,
    MAX(CASE WHEN level = 'model' AND rk = 1 THEN item END) AS reg_most_msrpd_model,
    MAX(CASE WHEN level = 'card' AND rk = 1 THEN item END) AS reg_most_msrpd_card
  FROM msrp_ranked
  WHERE rk = 1
  GROUP BY week
),

-- Step 9: Add lagged values for WoW calculation
weekly_data_with_lag AS (
  SELECT
        *,
        LAG(reg_num_listings, 1) OVER w AS reg_last_week_listing,
        LAG(reg_weekday_listing_pct, 1) OVER w AS reg_last_weekday_listing_pct,
        LAG(reg_nvidia_amd_ratio, 1) OVER w AS reg_last_nvidia_amd_ratio,
        LAG(reg_avg_price, 1) OVER w AS reg_last_week_avg_price,             -- Uses new avg price
        LAG(reg_pct_above_avg_price, 1) OVER w AS reg_last_pct_above_avg_price, -- Uses new comparison
        LAG(reg_avg_msrp_delta, 1) OVER w AS reg_last_week_avg_msrp_delta,
        LAG(reg_num_msrp_listings, 1) OVER w AS reg_last_week_num_msrp_listings,
        LAG(reg_msrp_listings_pct, 1) OVER w AS reg_last_week_msrp_listings_pct,
        LAG(reg_pct_over_20pct_msrp, 1) OVER w AS reg_last_pct_over_20pct_msrp,
        LAG(reg_daily_new_listings, 1) OVER w AS reg_last_week_daily_new_listings,
        LAG(reg_avg_minutes_between_listings, 1) OVER w AS reg_last_week_avg_minutes_between_listings
    FROM weekly_stats_derived
    WINDOW w AS (ORDER BY week ASC)
)

-- Step 10: Final SELECT with WoW calculations and joins (mostly unchanged structurally)
SELECT
    wdl.week,
    wdl.reg_num_listings AS reg_current_week_listings,
    wdl.reg_last_week_listing,
    (wdl.reg_num_listings / NULLIF(wdl.reg_last_week_listing, 0)) - 1 AS reg_wow_pct_listing,
    wdl.reg_weekday_listing_pct AS reg_current_weekday_listing_pct,
    wdl.reg_last_weekday_listing_pct,
    (wdl.reg_weekday_listing_pct / NULLIF(wdl.reg_last_weekday_listing_pct, 0)) - 1 AS reg_wow_weekday_pct,
    wdl.reg_nvidia_amd_ratio AS reg_current_nvidia_amd_ratio,
    wdl.reg_last_nvidia_amd_ratio,
    (wdl.reg_nvidia_amd_ratio / NULLIF(wdl.reg_last_nvidia_amd_ratio, 0)) - 1 AS reg_wow_pct_nvidia_amd_ratio,
    
    -- These use the new reg_avg_price calculation
    wdl.reg_avg_price AS reg_current_week_avg_price,
    wdl.reg_last_week_avg_price,
    (wdl.reg_avg_price / NULLIF(wdl.reg_last_week_avg_price, 0)) - 1 AS reg_wow_pct_avg_price,
    
    wdl.reg_pct_above_avg_price AS reg_current_pct_above_avg_price,
    wdl.reg_last_pct_above_avg_price,
    (wdl.reg_pct_above_avg_price / NULLIF(wdl.reg_last_pct_above_avg_price, 0)) - 1 AS reg_wow_pct_above_avg_price,

    wdl.reg_avg_msrp_delta AS reg_current_week_avg_msrp_delta,
    wdl.reg_last_week_avg_msrp_delta,
    CASE WHEN wdl.reg_last_week_avg_msrp_delta IS NULL OR ABS(wdl.reg_last_week_avg_msrp_delta) < 0.01 THEN NULL ELSE (wdl.reg_avg_msrp_delta - wdl.reg_last_week_avg_msrp_delta) / ABS(wdl.reg_last_week_avg_msrp_delta) END AS reg_wow_pct_avg_msrp_delta,
    wdl.reg_num_msrp_listings AS reg_current_week_num_msrp_listings,
    wdl.reg_last_week_num_msrp_listings,
    (wdl.reg_num_msrp_listings / NULLIF(wdl.reg_last_week_num_msrp_listings, 0)) - 1 AS reg_wow_pct_num_msrp_listings,
    wdl.reg_msrp_listings_pct AS reg_current_week_msrp_listings_pct,
    wdl.reg_last_week_msrp_listings_pct,
    (wdl.reg_msrp_listings_pct / NULLIF(wdl.reg_last_week_msrp_listings_pct, 0)) - 1 AS reg_wow_msrp_listings_pct,
    wdl.reg_pct_over_20pct_msrp AS reg_current_pct_over_20pct_msrp,
    wdl.reg_last_pct_over_20pct_msrp,
    (wdl.reg_pct_over_20pct_msrp / NULLIF(wdl.reg_last_pct_over_20pct_msrp, 0)) - 1 AS reg_wow_pct_over_20pct_msrp,
    wdl.reg_daily_new_listings AS reg_current_week_daily_new_listings,
    wdl.reg_last_week_daily_new_listings,
    (wdl.reg_daily_new_listings / NULLIF(wdl.reg_last_week_daily_new_listings, 0)) - 1 AS reg_wow_daily_new_listings,
    wdl.reg_avg_minutes_between_listings AS reg_current_week_avg_minutes_between_listings,
    wdl.reg_last_week_avg_minutes_between_listings,
    (wdl.reg_last_week_avg_minutes_between_listings / NULLIF(wdl.reg_avg_minutes_between_listings, 0)) - 1 AS reg_wow_pct_time_between_listings,
    COALESCE(tcm.reg_top_gpu_card, 'N/A') AS reg_top_gpu_card,
    COALESCE(tm.reg_top_gpu_model, 'N/A') AS reg_top_gpu_model,
    COALESCE(mm.reg_most_msrpd_model, 'N/A') as reg_most_msrpd_model,
    COALESCE(mm.reg_most_msrpd_card, 'N/A') as reg_most_msrpd_card
FROM weekly_data_with_lag wdl
LEFT JOIN top_cards_models tcm ON wdl.week = tcm.week
LEFT JOIN top_models tm ON wdl.week = tm.week
LEFT JOIN most_msrpd mm ON wdl.week = mm.week
ORDER BY wdl.week DESC;`;i.wow_listings_data&&(i.wow_listings_data instanceof Error?E.initialError=i.wow_listings_data:E.initialData=i.wow_listings_data,i.wow_listings_columns&&(E.knownColumns=i.wow_listings_columns));let G,F=!1;const H=x.createReactive({callback:C=>{_(0,G=C)},execFn:u},{id:"wow_listings",...E});H(y,{noResolve:N,...E}),globalThis[Symbol.for("wow_listings")]={get value(){return G}};let T={initialData:void 0,initialError:void 0},h=Xe`WITH listings_base AS (
    SELECT
        MessageDateTime,
        strftime(MessageDateTime, '%a') AS dayweek,
        MessageID,
        Manufacturer,
        'regular' AS listing_type
    FROM gpu_data.gpu
    -- FROM gpu_messages
    WHERE MessageDateTime >= (CURRENT_DATE - INTERVAL '37 days')

)

SELECT
    dayweek,
    Manufacturer,
    COUNT(DISTINCT MessageID) FILTER (WHERE listing_type = 'regular') AS regular_listing_count
FROM listings_base
GROUP BY
    dayweek,
    Manufacturer
ORDER BY
    CASE
        WHEN dayweek = 'Mon' THEN 1
        WHEN dayweek = 'Tue' THEN 2
        WHEN dayweek = 'Wed' THEN 3
        WHEN dayweek = 'Thu' THEN 4
        WHEN dayweek = 'Fri' THEN 5
        WHEN dayweek = 'Sat' THEN 6
        WHEN dayweek = 'Sun' THEN 7
    END ASC,
    Manufacturer ASC;`,f=`WITH listings_base AS (
    SELECT
        MessageDateTime,
        strftime(MessageDateTime, '%a') AS dayweek,
        MessageID,
        Manufacturer,
        'regular' AS listing_type
    FROM gpu_data.gpu
    -- FROM gpu_messages
    WHERE MessageDateTime >= (CURRENT_DATE - INTERVAL '37 days')

)

SELECT
    dayweek,
    Manufacturer,
    COUNT(DISTINCT MessageID) FILTER (WHERE listing_type = 'regular') AS regular_listing_count
FROM listings_base
GROUP BY
    dayweek,
    Manufacturer
ORDER BY
    CASE
        WHEN dayweek = 'Mon' THEN 1
        WHEN dayweek = 'Tue' THEN 2
        WHEN dayweek = 'Wed' THEN 3
        WHEN dayweek = 'Thu' THEN 4
        WHEN dayweek = 'Fri' THEN 5
        WHEN dayweek = 'Sat' THEN 6
        WHEN dayweek = 'Sun' THEN 7
    END ASC,
    Manufacturer ASC;`;i.daily_listings_by_manufacturer_data&&(i.daily_listings_by_manufacturer_data instanceof Error?T.initialError=i.daily_listings_by_manufacturer_data:T.initialData=i.daily_listings_by_manufacturer_data,i.daily_listings_by_manufacturer_columns&&(T.knownColumns=i.daily_listings_by_manufacturer_columns));let R,v=!1;const X=x.createReactive({callback:C=>{_(1,R=C)},execFn:u},{id:"daily_listings_by_manufacturer",...T});return X(f,{noResolve:h,...T}),globalThis[Symbol.for("daily_listings_by_manufacturer")]={get value(){return R}},a.$$set=C=>{"data"in C&&_(2,s=C.data)},a.$$.update=()=>{a.$$.dirty&4&&_(3,{data:i={},customFormattingSettings:n,__db:g}=s,i),a.$$.dirty&8&&e_.set(Object.keys(i).length>0),a.$$.dirty&4096&&t.params,a.$$.dirty&240&&(N||!F?N||(H(y,{noResolve:N,...E}),_(7,F=!0)):H(y,{noResolve:N})),a.$$.dirty&3840&&(h||!v?h||(X(f,{noResolve:h,...T}),_(11,v=!0)):X(f,{noResolve:h}))},_(5,N=Xe`-- wow_listings

-- Step 0: Calculate daily average of unique prices per GPU_Name
WITH daily_gpu_name_unique_price_avg AS (
  SELECT
    DATE_TRUNC('day', MessageDateTime) AS SaleDate,
    "GPU_Name",
    AVG(Price) AS AvgOfUniquePrices -- This AVG is over distinct prices for this GPU_Name on this SaleDate
  FROM (
    SELECT DISTINCT
        DATE_TRUNC('day', MessageDateTime) AS SaleDate_inner, -- Renamed to avoid ambiguity in some DBs
        MessageDateTime, -- Keep original for joining later if needed, or for week calculation
        "GPU_Name",
        Price
    FROM gpu_data.gpu
    WHERE "GPU_Name" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')
      AND Price IS NOT NULL AND Price > 0 -- Ensure we only consider valid, positive prices
  ) distinct_prices_per_day_gpu_name
  GROUP BY 1, 2 -- Group by SaleDate, "GPU_Name"
),

-- Step 1: Combine base tables and add listing_type
listings_base AS (
  SELECT
    MessageDateTime, MessageID, "GPU_Name", GPU_Model, Price, MSRP, AIB,
    'regular' AS listing_type
  FROM gpu_data.gpu
  WHERE "GPU_Name" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')
  -- Note: Price filtering for calculations will happen in later CTEs where averages are computed
),

-- Step 2: Enrich listings with common calculations and time gap
listings_enriched AS (
  SELECT
    lb.*,
    DATE_TRUNC('week', lb.MessageDateTime) AS week,
    DATE_TRUNC('day', lb.MessageDateTime) AS SaleDate, -- Add SaleDate for joining
    EXTRACT(DOW FROM lb.MessageDateTime) AS day_of_week,
    CASE WHEN EXTRACT(DOW FROM lb.MessageDateTime) IN (0, 6) THEN 'weekend' ELSE 'weekday' END AS day_type,
    CASE
      WHEN lb."GPU_Name" LIKE 'RTX%' THEN 'NVIDIA'
      WHEN lb."GPU_Name" LIKE 'RX%' THEN 'AMD'
      ELSE 'Other'
    END AS manufacturer,
    (lb.Price - lb.MSRP < 5 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_msrp,
    (lb.Price > lb.MSRP * 1.20 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_over_20pct_msrp,
    (lb.Price - lb.MSRP) AS msrp_delta,
    EXTRACT(EPOCH FROM (lb.MessageDateTime - LAG(lb.MessageDateTime) OVER (PARTITION BY DATE_TRUNC('week', lb.MessageDateTime), lb."GPU_Name" ORDER BY lb.MessageDateTime))) / 60.0 AS minutes_since_prev -- Partition by GPU_Name too? For per-GPU listing frequency. Or overall as before.
  FROM listings_base lb
),

-- Step 3: Calculate weekly average prices (THIS IS THE MAIN CHANGE FOR AVG PRICE)
-- This CTE will now average the daily unique GPU_Name averages.
weekly_avg_prices AS (
  SELECT
    DATE_TRUNC('week', dgnupa.SaleDate) AS week,
    AVG(dgnupa.AvgOfUniquePrices) as reg_avg_price_for_calc -- Average of daily averages of unique prices per GPU_Name
  FROM daily_gpu_name_unique_price_avg dgnupa
  GROUP BY 1
),

-- Step 4: Add flags indicating if a listing's PRICE is above the new weekly average
-- The comparison here is tricky. The weekly_avg_price is an average of daily averages.
-- Comparing an individual listing's price to this requires careful thought.
-- For now, I'll keep the structure, but the meaning of 'reg_is_above_avg' changes.
-- It means: is this specific listing's price higher than the weekly average of (daily averages of unique prices per GPU_Name)?
listings_with_avg_comparison AS (
  SELECT
    l.*,
    wap.reg_avg_price_for_calc,
    (l.Price > wap.reg_avg_price_for_calc AND l.Price IS NOT NULL AND l.Price > 0) as reg_is_above_avg
  FROM listings_enriched l
  LEFT JOIN weekly_avg_prices wap ON l.week = wap.week
),

-- Step 5: Aggregate weekly base statistics using conditional aggregation
weekly_stats AS (
  SELECT
    coalesce(lew.week, wap_main.week) as week, -- Use coalesce if listings_enriched might be empty for a week but daily_gpu_name_unique_price_avg has data
        
        -- Counts of listings (unaffected by price filters, taken from listings_enriched)
        COUNT_IF(lew.listing_type = 'regular') AS reg_num_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.day_type = 'weekday') AS reg_weekday_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'NVIDIA') AS reg_nvidia_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'AMD') AS reg_amd_listings,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_num_listings_with_valid_price,

        -- Pricing aggregates
        -- reg_avg_price is now sourced from the new weekly_avg_prices CTE (which itself is an avg of daily avgs)
        MAX(wap_main.reg_avg_price_for_calc) AS reg_avg_price, -- MAX because wap_main is grouped by week
        
        -- reg_listed_volume should still sum actual prices of listings
        SUM(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.Price END) AS reg_listed_volume,
        
        -- reg_avg_msrp_delta: this should average the deltas from actual listings
        AVG(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.msrp_delta END) FILTER (WHERE lew.MSRP IS NOT NULL) AS reg_avg_msrp_delta,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.is_msrp) AS reg_num_msrp_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.is_over_20pct_msrp) AS reg_num_over_20pct_msrp,
        
        AVG(CASE WHEN lew.listing_type = 'regular' THEN lew.minutes_since_prev END) AS reg_avg_minutes_between_listings,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.reg_is_above_avg) AS reg_num_above_avg_price,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.MSRP IS NOT NULL AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_total_with_msrp 

    FROM listings_with_avg_comparison lew
    -- FULL JOIN with weekly_avg_prices to ensure weeks with only price data (no listings after filtering) are included for reg_avg_price
    FULL JOIN weekly_avg_prices wap_main ON lew.week = wap_main.week
    GROUP BY 1 -- Group by week
),

-- Step 6: Calculate derived weekly metrics (percentages, ratios)
-- This CTE should largely remain the same, as it operates on the outputs of weekly_stats
weekly_stats_derived AS (
    SELECT
        *,
        reg_num_listings / 7.0 AS reg_daily_new_listings,
        COALESCE(reg_weekday_listings * 1.0 / NULLIF(reg_num_listings, 0), 0) AS reg_weekday_listing_pct,
        COALESCE(reg_nvidia_listings * 1.0 / NULLIF(reg_amd_listings, 0), NULL) AS reg_nvidia_amd_ratio,
        COALESCE(reg_num_msrp_listings * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_msrp_listings_pct,
        COALESCE(reg_num_over_20pct_msrp * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_pct_over_20pct_msrp,
        COALESCE(reg_num_above_avg_price * 1.0 / NULLIF(reg_num_listings_with_valid_price, 0), 0) AS reg_pct_above_avg_price
    FROM weekly_stats ws
),

-- Step 7a: Rank top cards/models for 'regular' listings (Unaffected by price filters)
reg_top_cards_ranked AS (
  SELECT
    week,
    "GPU_Name",
    COUNT(*) as cnt,
    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, "GPU_Name") as rk
  FROM listings_enriched -- Counts all listings from enriched base
  WHERE listing_type = 'regular'
  GROUP BY week, "GPU_Name"
),
reg_top_models_ranked AS (
  SELECT
    week,
    GPU_Model,
    COUNT(*) as cnt,
    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, GPU_Model) as rk
  FROM listings_enriched -- Counts all listings from enriched base
  WHERE listing_type = 'regular' AND GPU_Model IS NOT NULL
  GROUP BY week, GPU_Model
),

-- Step 7c: Calculate base MSRP stats per item/level for ranking
msrp_stats_base AS (
  SELECT
    week, AIB, GPU_Model, "GPU_Name",
    COUNT(*) AS num_msrp_listings
  FROM listings_enriched
  WHERE is_msrp AND listing_type = 'regular'
  GROUP BY week, AIB, GPU_Model, "GPU_Name"
),
msrp_total_counts AS (
  SELECT
    week, AIB, GPU_Model, "GPU_Name",
    COUNT(*) as total_listings
  FROM listings_enriched
  WHERE MSRP IS NOT NULL AND listing_type = 'regular' AND Price IS NOT NULL AND Price > 0
  GROUP BY week, AIB, GPU_Model, "GPU_Name"
),
msrp_stats_agg AS (
  SELECT
    tc.week, 'model' as level, tc.GPU_Model as item,
    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,
    SUM(tc.total_listings) AS total_listings
  FROM msrp_total_counts tc
  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc."GPU_Name" = msb."GPU_Name"
  WHERE tc.GPU_Model IS NOT NULL
  GROUP BY tc.week, tc.GPU_Model
  UNION ALL
  SELECT
    tc.week, 'card' as level, tc."GPU_Name" as item,
    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,
    SUM(tc.total_listings) AS total_listings
  FROM msrp_total_counts tc
  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc."GPU_Name" = msb."GPU_Name"
  GROUP BY tc.week, tc."GPU_Name"
),

-- Step 7d: Rank REGULAR MSRP items by percentage
msrp_ranked AS (
  SELECT
    week, level, item, total_listings,
    COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) AS msrp_pct,
    RANK() OVER (PARTITION BY week, level ORDER BY COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) DESC, total_listings DESC, item) as rk
  FROM msrp_stats_agg
  WHERE total_listings > 0 
),

-- Step 8a: Select top cards/models per week
top_cards_models AS (
    SELECT week, MAX(CASE WHEN rk=1 THEN "GPU_Name" END) as reg_top_gpu_card
    FROM reg_top_cards_ranked WHERE rk = 1 GROUP BY week
),
top_models AS (
     SELECT week, MAX(CASE WHEN rk=1 THEN GPU_Model END) as reg_top_gpu_model
    FROM reg_top_models_ranked WHERE rk = 1 GROUP BY week
),

-- Step 8b: Select top MSRP'd items per week
most_msrpd AS (
  SELECT week,
    MAX(CASE WHEN level = 'model' AND rk = 1 THEN item END) AS reg_most_msrpd_model,
    MAX(CASE WHEN level = 'card' AND rk = 1 THEN item END) AS reg_most_msrpd_card
  FROM msrp_ranked
  WHERE rk = 1
  GROUP BY week
),

-- Step 9: Add lagged values for WoW calculation
weekly_data_with_lag AS (
  SELECT
        *,
        LAG(reg_num_listings, 1) OVER w AS reg_last_week_listing,
        LAG(reg_weekday_listing_pct, 1) OVER w AS reg_last_weekday_listing_pct,
        LAG(reg_nvidia_amd_ratio, 1) OVER w AS reg_last_nvidia_amd_ratio,
        LAG(reg_avg_price, 1) OVER w AS reg_last_week_avg_price,             -- Uses new avg price
        LAG(reg_pct_above_avg_price, 1) OVER w AS reg_last_pct_above_avg_price, -- Uses new comparison
        LAG(reg_avg_msrp_delta, 1) OVER w AS reg_last_week_avg_msrp_delta,
        LAG(reg_num_msrp_listings, 1) OVER w AS reg_last_week_num_msrp_listings,
        LAG(reg_msrp_listings_pct, 1) OVER w AS reg_last_week_msrp_listings_pct,
        LAG(reg_pct_over_20pct_msrp, 1) OVER w AS reg_last_pct_over_20pct_msrp,
        LAG(reg_daily_new_listings, 1) OVER w AS reg_last_week_daily_new_listings,
        LAG(reg_avg_minutes_between_listings, 1) OVER w AS reg_last_week_avg_minutes_between_listings
    FROM weekly_stats_derived
    WINDOW w AS (ORDER BY week ASC)
)

-- Step 10: Final SELECT with WoW calculations and joins (mostly unchanged structurally)
SELECT
    wdl.week,
    wdl.reg_num_listings AS reg_current_week_listings,
    wdl.reg_last_week_listing,
    (wdl.reg_num_listings / NULLIF(wdl.reg_last_week_listing, 0)) - 1 AS reg_wow_pct_listing,
    wdl.reg_weekday_listing_pct AS reg_current_weekday_listing_pct,
    wdl.reg_last_weekday_listing_pct,
    (wdl.reg_weekday_listing_pct / NULLIF(wdl.reg_last_weekday_listing_pct, 0)) - 1 AS reg_wow_weekday_pct,
    wdl.reg_nvidia_amd_ratio AS reg_current_nvidia_amd_ratio,
    wdl.reg_last_nvidia_amd_ratio,
    (wdl.reg_nvidia_amd_ratio / NULLIF(wdl.reg_last_nvidia_amd_ratio, 0)) - 1 AS reg_wow_pct_nvidia_amd_ratio,
    
    -- These use the new reg_avg_price calculation
    wdl.reg_avg_price AS reg_current_week_avg_price,
    wdl.reg_last_week_avg_price,
    (wdl.reg_avg_price / NULLIF(wdl.reg_last_week_avg_price, 0)) - 1 AS reg_wow_pct_avg_price,
    
    wdl.reg_pct_above_avg_price AS reg_current_pct_above_avg_price,
    wdl.reg_last_pct_above_avg_price,
    (wdl.reg_pct_above_avg_price / NULLIF(wdl.reg_last_pct_above_avg_price, 0)) - 1 AS reg_wow_pct_above_avg_price,

    wdl.reg_avg_msrp_delta AS reg_current_week_avg_msrp_delta,
    wdl.reg_last_week_avg_msrp_delta,
    CASE WHEN wdl.reg_last_week_avg_msrp_delta IS NULL OR ABS(wdl.reg_last_week_avg_msrp_delta) < 0.01 THEN NULL ELSE (wdl.reg_avg_msrp_delta - wdl.reg_last_week_avg_msrp_delta) / ABS(wdl.reg_last_week_avg_msrp_delta) END AS reg_wow_pct_avg_msrp_delta,
    wdl.reg_num_msrp_listings AS reg_current_week_num_msrp_listings,
    wdl.reg_last_week_num_msrp_listings,
    (wdl.reg_num_msrp_listings / NULLIF(wdl.reg_last_week_num_msrp_listings, 0)) - 1 AS reg_wow_pct_num_msrp_listings,
    wdl.reg_msrp_listings_pct AS reg_current_week_msrp_listings_pct,
    wdl.reg_last_week_msrp_listings_pct,
    (wdl.reg_msrp_listings_pct / NULLIF(wdl.reg_last_week_msrp_listings_pct, 0)) - 1 AS reg_wow_msrp_listings_pct,
    wdl.reg_pct_over_20pct_msrp AS reg_current_pct_over_20pct_msrp,
    wdl.reg_last_pct_over_20pct_msrp,
    (wdl.reg_pct_over_20pct_msrp / NULLIF(wdl.reg_last_pct_over_20pct_msrp, 0)) - 1 AS reg_wow_pct_over_20pct_msrp,
    wdl.reg_daily_new_listings AS reg_current_week_daily_new_listings,
    wdl.reg_last_week_daily_new_listings,
    (wdl.reg_daily_new_listings / NULLIF(wdl.reg_last_week_daily_new_listings, 0)) - 1 AS reg_wow_daily_new_listings,
    wdl.reg_avg_minutes_between_listings AS reg_current_week_avg_minutes_between_listings,
    wdl.reg_last_week_avg_minutes_between_listings,
    (wdl.reg_last_week_avg_minutes_between_listings / NULLIF(wdl.reg_avg_minutes_between_listings, 0)) - 1 AS reg_wow_pct_time_between_listings,
    COALESCE(tcm.reg_top_gpu_card, 'N/A') AS reg_top_gpu_card,
    COALESCE(tm.reg_top_gpu_model, 'N/A') AS reg_top_gpu_model,
    COALESCE(mm.reg_most_msrpd_model, 'N/A') as reg_most_msrpd_model,
    COALESCE(mm.reg_most_msrpd_card, 'N/A') as reg_most_msrpd_card
FROM weekly_data_with_lag wdl
LEFT JOIN top_cards_models tcm ON wdl.week = tcm.week
LEFT JOIN top_models tm ON wdl.week = tm.week
LEFT JOIN most_msrpd mm ON wdl.week = mm.week
ORDER BY wdl.week DESC;`),_(6,y=`-- wow_listings

-- Step 0: Calculate daily average of unique prices per GPU_Name
WITH daily_gpu_name_unique_price_avg AS (
  SELECT
    DATE_TRUNC('day', MessageDateTime) AS SaleDate,
    "GPU_Name",
    AVG(Price) AS AvgOfUniquePrices -- This AVG is over distinct prices for this GPU_Name on this SaleDate
  FROM (
    SELECT DISTINCT
        DATE_TRUNC('day', MessageDateTime) AS SaleDate_inner, -- Renamed to avoid ambiguity in some DBs
        MessageDateTime, -- Keep original for joining later if needed, or for week calculation
        "GPU_Name",
        Price
    FROM gpu_data.gpu
    WHERE "GPU_Name" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')
      AND Price IS NOT NULL AND Price > 0 -- Ensure we only consider valid, positive prices
  ) distinct_prices_per_day_gpu_name
  GROUP BY 1, 2 -- Group by SaleDate, "GPU_Name"
),

-- Step 1: Combine base tables and add listing_type
listings_base AS (
  SELECT
    MessageDateTime, MessageID, "GPU_Name", GPU_Model, Price, MSRP, AIB,
    'regular' AS listing_type
  FROM gpu_data.gpu
  WHERE "GPU_Name" IN ('RTX 5080', 'RTX 5070', 'RTX 5070 Ti', 'RTX 5090', 'RX 9070', 'RX 9070 XT')
  -- Note: Price filtering for calculations will happen in later CTEs where averages are computed
),

-- Step 2: Enrich listings with common calculations and time gap
listings_enriched AS (
  SELECT
    lb.*,
    DATE_TRUNC('week', lb.MessageDateTime) AS week,
    DATE_TRUNC('day', lb.MessageDateTime) AS SaleDate, -- Add SaleDate for joining
    EXTRACT(DOW FROM lb.MessageDateTime) AS day_of_week,
    CASE WHEN EXTRACT(DOW FROM lb.MessageDateTime) IN (0, 6) THEN 'weekend' ELSE 'weekday' END AS day_type,
    CASE
      WHEN lb."GPU_Name" LIKE 'RTX%' THEN 'NVIDIA'
      WHEN lb."GPU_Name" LIKE 'RX%' THEN 'AMD'
      ELSE 'Other'
    END AS manufacturer,
    (lb.Price - lb.MSRP < 5 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_msrp,
    (lb.Price > lb.MSRP * 1.20 AND lb.MSRP IS NOT NULL AND lb.Price IS NOT NULL AND lb.Price > 0) AS is_over_20pct_msrp,
    (lb.Price - lb.MSRP) AS msrp_delta,
    EXTRACT(EPOCH FROM (lb.MessageDateTime - LAG(lb.MessageDateTime) OVER (PARTITION BY DATE_TRUNC('week', lb.MessageDateTime), lb."GPU_Name" ORDER BY lb.MessageDateTime))) / 60.0 AS minutes_since_prev -- Partition by GPU_Name too? For per-GPU listing frequency. Or overall as before.
  FROM listings_base lb
),

-- Step 3: Calculate weekly average prices (THIS IS THE MAIN CHANGE FOR AVG PRICE)
-- This CTE will now average the daily unique GPU_Name averages.
weekly_avg_prices AS (
  SELECT
    DATE_TRUNC('week', dgnupa.SaleDate) AS week,
    AVG(dgnupa.AvgOfUniquePrices) as reg_avg_price_for_calc -- Average of daily averages of unique prices per GPU_Name
  FROM daily_gpu_name_unique_price_avg dgnupa
  GROUP BY 1
),

-- Step 4: Add flags indicating if a listing's PRICE is above the new weekly average
-- The comparison here is tricky. The weekly_avg_price is an average of daily averages.
-- Comparing an individual listing's price to this requires careful thought.
-- For now, I'll keep the structure, but the meaning of 'reg_is_above_avg' changes.
-- It means: is this specific listing's price higher than the weekly average of (daily averages of unique prices per GPU_Name)?
listings_with_avg_comparison AS (
  SELECT
    l.*,
    wap.reg_avg_price_for_calc,
    (l.Price > wap.reg_avg_price_for_calc AND l.Price IS NOT NULL AND l.Price > 0) as reg_is_above_avg
  FROM listings_enriched l
  LEFT JOIN weekly_avg_prices wap ON l.week = wap.week
),

-- Step 5: Aggregate weekly base statistics using conditional aggregation
weekly_stats AS (
  SELECT
    coalesce(lew.week, wap_main.week) as week, -- Use coalesce if listings_enriched might be empty for a week but daily_gpu_name_unique_price_avg has data
        
        -- Counts of listings (unaffected by price filters, taken from listings_enriched)
        COUNT_IF(lew.listing_type = 'regular') AS reg_num_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.day_type = 'weekday') AS reg_weekday_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'NVIDIA') AS reg_nvidia_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.manufacturer = 'AMD') AS reg_amd_listings,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_num_listings_with_valid_price,

        -- Pricing aggregates
        -- reg_avg_price is now sourced from the new weekly_avg_prices CTE (which itself is an avg of daily avgs)
        MAX(wap_main.reg_avg_price_for_calc) AS reg_avg_price, -- MAX because wap_main is grouped by week
        
        -- reg_listed_volume should still sum actual prices of listings
        SUM(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.Price END) AS reg_listed_volume,
        
        -- reg_avg_msrp_delta: this should average the deltas from actual listings
        AVG(CASE WHEN lew.listing_type = 'regular' AND lew.Price IS NOT NULL AND lew.Price > 0 THEN lew.msrp_delta END) FILTER (WHERE lew.MSRP IS NOT NULL) AS reg_avg_msrp_delta,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.is_msrp) AS reg_num_msrp_listings,
        COUNT_IF(lew.listing_type = 'regular' AND lew.is_over_20pct_msrp) AS reg_num_over_20pct_msrp,
        
        AVG(CASE WHEN lew.listing_type = 'regular' THEN lew.minutes_since_prev END) AS reg_avg_minutes_between_listings,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.reg_is_above_avg) AS reg_num_above_avg_price,
        
        COUNT_IF(lew.listing_type = 'regular' AND lew.MSRP IS NOT NULL AND lew.Price IS NOT NULL AND lew.Price > 0) AS reg_total_with_msrp 

    FROM listings_with_avg_comparison lew
    -- FULL JOIN with weekly_avg_prices to ensure weeks with only price data (no listings after filtering) are included for reg_avg_price
    FULL JOIN weekly_avg_prices wap_main ON lew.week = wap_main.week
    GROUP BY 1 -- Group by week
),

-- Step 6: Calculate derived weekly metrics (percentages, ratios)
-- This CTE should largely remain the same, as it operates on the outputs of weekly_stats
weekly_stats_derived AS (
    SELECT
        *,
        reg_num_listings / 7.0 AS reg_daily_new_listings,
        COALESCE(reg_weekday_listings * 1.0 / NULLIF(reg_num_listings, 0), 0) AS reg_weekday_listing_pct,
        COALESCE(reg_nvidia_listings * 1.0 / NULLIF(reg_amd_listings, 0), NULL) AS reg_nvidia_amd_ratio,
        COALESCE(reg_num_msrp_listings * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_msrp_listings_pct,
        COALESCE(reg_num_over_20pct_msrp * 1.0 / NULLIF(reg_total_with_msrp, 0), 0) AS reg_pct_over_20pct_msrp,
        COALESCE(reg_num_above_avg_price * 1.0 / NULLIF(reg_num_listings_with_valid_price, 0), 0) AS reg_pct_above_avg_price
    FROM weekly_stats ws
),

-- Step 7a: Rank top cards/models for 'regular' listings (Unaffected by price filters)
reg_top_cards_ranked AS (
  SELECT
    week,
    "GPU_Name",
    COUNT(*) as cnt,
    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, "GPU_Name") as rk
  FROM listings_enriched -- Counts all listings from enriched base
  WHERE listing_type = 'regular'
  GROUP BY week, "GPU_Name"
),
reg_top_models_ranked AS (
  SELECT
    week,
    GPU_Model,
    COUNT(*) as cnt,
    RANK() OVER (PARTITION BY week ORDER BY COUNT(*) DESC, GPU_Model) as rk
  FROM listings_enriched -- Counts all listings from enriched base
  WHERE listing_type = 'regular' AND GPU_Model IS NOT NULL
  GROUP BY week, GPU_Model
),

-- Step 7c: Calculate base MSRP stats per item/level for ranking
msrp_stats_base AS (
  SELECT
    week, AIB, GPU_Model, "GPU_Name",
    COUNT(*) AS num_msrp_listings
  FROM listings_enriched
  WHERE is_msrp AND listing_type = 'regular'
  GROUP BY week, AIB, GPU_Model, "GPU_Name"
),
msrp_total_counts AS (
  SELECT
    week, AIB, GPU_Model, "GPU_Name",
    COUNT(*) as total_listings
  FROM listings_enriched
  WHERE MSRP IS NOT NULL AND listing_type = 'regular' AND Price IS NOT NULL AND Price > 0
  GROUP BY week, AIB, GPU_Model, "GPU_Name"
),
msrp_stats_agg AS (
  SELECT
    tc.week, 'model' as level, tc.GPU_Model as item,
    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,
    SUM(tc.total_listings) AS total_listings
  FROM msrp_total_counts tc
  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc."GPU_Name" = msb."GPU_Name"
  WHERE tc.GPU_Model IS NOT NULL
  GROUP BY tc.week, tc.GPU_Model
  UNION ALL
  SELECT
    tc.week, 'card' as level, tc."GPU_Name" as item,
    SUM(COALESCE(msb.num_msrp_listings, 0)) AS num_msrp_listings,
    SUM(tc.total_listings) AS total_listings
  FROM msrp_total_counts tc
  LEFT JOIN msrp_stats_base msb ON tc.week = msb.week AND tc.GPU_Model = msb.GPU_Model AND tc.AIB = msb.AIB AND tc."GPU_Name" = msb."GPU_Name"
  GROUP BY tc.week, tc."GPU_Name"
),

-- Step 7d: Rank REGULAR MSRP items by percentage
msrp_ranked AS (
  SELECT
    week, level, item, total_listings,
    COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) AS msrp_pct,
    RANK() OVER (PARTITION BY week, level ORDER BY COALESCE(num_msrp_listings * 1.0 / NULLIF(total_listings, 0), 0) DESC, total_listings DESC, item) as rk
  FROM msrp_stats_agg
  WHERE total_listings > 0 
),

-- Step 8a: Select top cards/models per week
top_cards_models AS (
    SELECT week, MAX(CASE WHEN rk=1 THEN "GPU_Name" END) as reg_top_gpu_card
    FROM reg_top_cards_ranked WHERE rk = 1 GROUP BY week
),
top_models AS (
     SELECT week, MAX(CASE WHEN rk=1 THEN GPU_Model END) as reg_top_gpu_model
    FROM reg_top_models_ranked WHERE rk = 1 GROUP BY week
),

-- Step 8b: Select top MSRP'd items per week
most_msrpd AS (
  SELECT week,
    MAX(CASE WHEN level = 'model' AND rk = 1 THEN item END) AS reg_most_msrpd_model,
    MAX(CASE WHEN level = 'card' AND rk = 1 THEN item END) AS reg_most_msrpd_card
  FROM msrp_ranked
  WHERE rk = 1
  GROUP BY week
),

-- Step 9: Add lagged values for WoW calculation
weekly_data_with_lag AS (
  SELECT
        *,
        LAG(reg_num_listings, 1) OVER w AS reg_last_week_listing,
        LAG(reg_weekday_listing_pct, 1) OVER w AS reg_last_weekday_listing_pct,
        LAG(reg_nvidia_amd_ratio, 1) OVER w AS reg_last_nvidia_amd_ratio,
        LAG(reg_avg_price, 1) OVER w AS reg_last_week_avg_price,             -- Uses new avg price
        LAG(reg_pct_above_avg_price, 1) OVER w AS reg_last_pct_above_avg_price, -- Uses new comparison
        LAG(reg_avg_msrp_delta, 1) OVER w AS reg_last_week_avg_msrp_delta,
        LAG(reg_num_msrp_listings, 1) OVER w AS reg_last_week_num_msrp_listings,
        LAG(reg_msrp_listings_pct, 1) OVER w AS reg_last_week_msrp_listings_pct,
        LAG(reg_pct_over_20pct_msrp, 1) OVER w AS reg_last_pct_over_20pct_msrp,
        LAG(reg_daily_new_listings, 1) OVER w AS reg_last_week_daily_new_listings,
        LAG(reg_avg_minutes_between_listings, 1) OVER w AS reg_last_week_avg_minutes_between_listings
    FROM weekly_stats_derived
    WINDOW w AS (ORDER BY week ASC)
)

-- Step 10: Final SELECT with WoW calculations and joins (mostly unchanged structurally)
SELECT
    wdl.week,
    wdl.reg_num_listings AS reg_current_week_listings,
    wdl.reg_last_week_listing,
    (wdl.reg_num_listings / NULLIF(wdl.reg_last_week_listing, 0)) - 1 AS reg_wow_pct_listing,
    wdl.reg_weekday_listing_pct AS reg_current_weekday_listing_pct,
    wdl.reg_last_weekday_listing_pct,
    (wdl.reg_weekday_listing_pct / NULLIF(wdl.reg_last_weekday_listing_pct, 0)) - 1 AS reg_wow_weekday_pct,
    wdl.reg_nvidia_amd_ratio AS reg_current_nvidia_amd_ratio,
    wdl.reg_last_nvidia_amd_ratio,
    (wdl.reg_nvidia_amd_ratio / NULLIF(wdl.reg_last_nvidia_amd_ratio, 0)) - 1 AS reg_wow_pct_nvidia_amd_ratio,
    
    -- These use the new reg_avg_price calculation
    wdl.reg_avg_price AS reg_current_week_avg_price,
    wdl.reg_last_week_avg_price,
    (wdl.reg_avg_price / NULLIF(wdl.reg_last_week_avg_price, 0)) - 1 AS reg_wow_pct_avg_price,
    
    wdl.reg_pct_above_avg_price AS reg_current_pct_above_avg_price,
    wdl.reg_last_pct_above_avg_price,
    (wdl.reg_pct_above_avg_price / NULLIF(wdl.reg_last_pct_above_avg_price, 0)) - 1 AS reg_wow_pct_above_avg_price,

    wdl.reg_avg_msrp_delta AS reg_current_week_avg_msrp_delta,
    wdl.reg_last_week_avg_msrp_delta,
    CASE WHEN wdl.reg_last_week_avg_msrp_delta IS NULL OR ABS(wdl.reg_last_week_avg_msrp_delta) < 0.01 THEN NULL ELSE (wdl.reg_avg_msrp_delta - wdl.reg_last_week_avg_msrp_delta) / ABS(wdl.reg_last_week_avg_msrp_delta) END AS reg_wow_pct_avg_msrp_delta,
    wdl.reg_num_msrp_listings AS reg_current_week_num_msrp_listings,
    wdl.reg_last_week_num_msrp_listings,
    (wdl.reg_num_msrp_listings / NULLIF(wdl.reg_last_week_num_msrp_listings, 0)) - 1 AS reg_wow_pct_num_msrp_listings,
    wdl.reg_msrp_listings_pct AS reg_current_week_msrp_listings_pct,
    wdl.reg_last_week_msrp_listings_pct,
    (wdl.reg_msrp_listings_pct / NULLIF(wdl.reg_last_week_msrp_listings_pct, 0)) - 1 AS reg_wow_msrp_listings_pct,
    wdl.reg_pct_over_20pct_msrp AS reg_current_pct_over_20pct_msrp,
    wdl.reg_last_pct_over_20pct_msrp,
    (wdl.reg_pct_over_20pct_msrp / NULLIF(wdl.reg_last_pct_over_20pct_msrp, 0)) - 1 AS reg_wow_pct_over_20pct_msrp,
    wdl.reg_daily_new_listings AS reg_current_week_daily_new_listings,
    wdl.reg_last_week_daily_new_listings,
    (wdl.reg_daily_new_listings / NULLIF(wdl.reg_last_week_daily_new_listings, 0)) - 1 AS reg_wow_daily_new_listings,
    wdl.reg_avg_minutes_between_listings AS reg_current_week_avg_minutes_between_listings,
    wdl.reg_last_week_avg_minutes_between_listings,
    (wdl.reg_last_week_avg_minutes_between_listings / NULLIF(wdl.reg_avg_minutes_between_listings, 0)) - 1 AS reg_wow_pct_time_between_listings,
    COALESCE(tcm.reg_top_gpu_card, 'N/A') AS reg_top_gpu_card,
    COALESCE(tm.reg_top_gpu_model, 'N/A') AS reg_top_gpu_model,
    COALESCE(mm.reg_most_msrpd_model, 'N/A') as reg_most_msrpd_model,
    COALESCE(mm.reg_most_msrpd_card, 'N/A') as reg_most_msrpd_card
FROM weekly_data_with_lag wdl
LEFT JOIN top_cards_models tcm ON wdl.week = tcm.week
LEFT JOIN top_models tm ON wdl.week = tm.week
LEFT JOIN most_msrpd mm ON wdl.week = mm.week
ORDER BY wdl.week DESC;`),_(9,h=Xe`WITH listings_base AS (
    SELECT
        MessageDateTime,
        strftime(MessageDateTime, '%a') AS dayweek,
        MessageID,
        Manufacturer,
        'regular' AS listing_type
    FROM gpu_data.gpu
    -- FROM gpu_messages
    WHERE MessageDateTime >= (CURRENT_DATE - INTERVAL '37 days')

)

SELECT
    dayweek,
    Manufacturer,
    COUNT(DISTINCT MessageID) FILTER (WHERE listing_type = 'regular') AS regular_listing_count
FROM listings_base
GROUP BY
    dayweek,
    Manufacturer
ORDER BY
    CASE
        WHEN dayweek = 'Mon' THEN 1
        WHEN dayweek = 'Tue' THEN 2
        WHEN dayweek = 'Wed' THEN 3
        WHEN dayweek = 'Thu' THEN 4
        WHEN dayweek = 'Fri' THEN 5
        WHEN dayweek = 'Sat' THEN 6
        WHEN dayweek = 'Sun' THEN 7
    END ASC,
    Manufacturer ASC;`),_(10,f=`WITH listings_base AS (
    SELECT
        MessageDateTime,
        strftime(MessageDateTime, '%a') AS dayweek,
        MessageID,
        Manufacturer,
        'regular' AS listing_type
    FROM gpu_data.gpu
    -- FROM gpu_messages
    WHERE MessageDateTime >= (CURRENT_DATE - INTERVAL '37 days')

)

SELECT
    dayweek,
    Manufacturer,
    COUNT(DISTINCT MessageID) FILTER (WHERE listing_type = 'regular') AS regular_listing_count
FROM listings_base
GROUP BY
    dayweek,
    Manufacturer
ORDER BY
    CASE
        WHEN dayweek = 'Mon' THEN 1
        WHEN dayweek = 'Tue' THEN 2
        WHEN dayweek = 'Wed' THEN 3
        WHEN dayweek = 'Thu' THEN 4
        WHEN dayweek = 'Fri' THEN 5
        WHEN dayweek = 'Sat' THEN 6
        WHEN dayweek = 'Sun' THEN 7
    END ASC,
    Manufacturer ASC;`),[G,R,s,i,E,N,y,F,T,h,f,v,t]}class cs extends Ne{constructor(e){super(),ke(this,e,es,x_,Ee,{data:2})}}export{cs as component};
